Skalierung von nebenlÃ¤ufigen und
verteilten Simulationssystemen fÃ¼r
interagierende Agenten


An der UniversitÃ¤t Hamburg eingereichte
D i s s e r t a t i o n
zur Erlangung des akademischen Grads
Dr. rer. nat.


Jan Henrik RÃ¶wekamp
aus Hamburg


Hamburg, 2023


Dissertation zur Erlangung der WÃ¼rde des Doktors der Naturwissenschaften der
FakultÃ¤t fÃ¼r Mathematik, Informatik und Naturwissenschaften,
Fachbereich Informatik der UniversitÃ¤t Hamburg
vorgelegt von Jan Henrik RÃ¶wekamp aus Hamburg.


Gutachten wurden erstellt von:
Dr. Daniel Moldt
Prof. Dr. Leonie Dreschler-Fischer
Prof. Dr. Karsten Wolf


PrÃ¼fungskomission:


Prof. Dr. Peter Kling (Vorsitz)
Dr. Daniel Moldt
Prof. Dr. Leonie Dreschler-Fischer
Prof. Dr. Norbert Ritter


Tag der Disputation:


22. Juli 2022


Betreuung:


Dr. Daniel Moldt
Prof. Dr. Leonie Dreschler-Fischer


Zusammenfassung


Diese Arbeit behandelt die Integration von dynamischer Skalierbarkeit, dynami-
scher Anpassung und modellbasierten Simulationssystemen. Diese Simulations-
systeme sind dabei auf die nebenlÃ¤ufige Simulation von auf Plattformen inter-
agierenden Agenten ausgelegt. Das zentrale Ergebnis hierbei ist die im Rahmen
der Arbeit eingefÃ¼hrte Â»Mushu-ArchitekturÂ«. Diese beschreibt in diesem Kon-
text ein Agentensystem, in welchem Agenten, heterogene Plattformen und das
Management von Plattformen in einer integrierten Architektur bestehen. Dabei
sind Agenten durch das Design der Architektur explizit in der Lage dynamischen
Einfluss auf die Form ihrer Plattformen und deren Anzahl zu nehmen.


In der realen Welt treten EntitÃ¤ten wie Systeme und insbesondere Menschen
stets in einem bestimmten Raum oder Rahmen miteinander in Interaktion. Die
Mushu-Architektur beabsichtigt die MÃ¶glichkeit dieser EntitÃ¤ten spontan RÃ¤ume
fÃ¼r die Kommunikation und Interaktion zu schaffen konzeptuell abzubilden. Die
agentenorientierte Softwareentwicklung bietet hierfÃ¼r eine solide Grundlage und
interpretiert die genannten EntitÃ¤ten als Agenten. Die Simulation groÃŸer Systeme
ist jedoch ab einer gewissen GrÃ¶ÃŸe auf einzelnen Maschinen nicht mehr mÃ¶glich
oder kosteneï¬€izient. Daher wurde die Mushu-Architektur unter der MaÃŸgabe
entworfen, dass in einer Realisierung die Gesamtarchitektur ein verteiltes System
beschreibt und die Plattformen die grÃ¶ÃŸten lokalen Einheiten darstellen. Es wird
hergeleitet, dass die dynamische Erzeugung von Plattformen durch Agenten als
Skalierungsoperation auf der technischen Ebene beschrieben werden kann. Auf
technischer Ebene beschreibt die Mushu-Architektur gleichermaÃŸen Anteile von
Softwarekomponente bis Deploymentlandschaft.


Als letzter verbleibender Punkt wird die Abbildung von Realweltsituationen auf
derartige Modelle adressiert. Eine geeignete Methodik dafÃ¼r besteht im Kontext
der Szenenanalyse, bei welcher aus (Bild)daten und Wissen Hypothesen Ã¼ber
beobachtete Situationen abgeleitet werden, passend zum generellen agentenori-
entierten Ansatz. Da eine umfassende Betrachtung dieses Ablaufs den Umfang
mehrerer eigener Arbeiten hÃ¤tte, motiviert diese Arbeit lediglich diesen Weg. Da-
bei wird dargelegt, dass es gerade bei umfangreichen Berechnungen vorteilhaft ist,
eine solche Abbildung schneller durchfÃ¼hren zu kÃ¶nnen. Um hierbei einen Beitrag
zu leisten, wird eine Heuristik eingefÃ¼hrt, welche grundlegend fÃ¼r die Beschleuni-
gung einer Klasse an Mustererkennungsalgorithmen eingesetzt werden kann.


Die Arbeit verfolgt einen dreistufigen Ansatz von Konzeptualisierung, Realisie-
rungskonzept und Beschreibung von Prototypen. In der Konzeptualisierung wird
die abstrakte Architektur beschrieben, im Realisierungskonzept die Abbildung auf
bestehende (oder zu konstruierende) Technologieformen und schlussendlich in den
Prototypen die Abbildung des Realisierungskonzepts auf konkrete Technologien,
Frameworks, etc. sowie erfolgte Implementationen.


Abstract


This thesis addresses the integration of dynamic scalability, dynamic adaptation
and model-based simulation systems, which are designed for the concurrent simu-
lation of agents interacting on platforms. The main result is the newly introduced
â€œMushu architectureâ€. It describes an agent system, in which agents, heteroge-
neous platforms and the management of platforms exist in an integrated archi-
tecture, where agents are explicitly able to dynamically influence their platforms
themselves as well as the platform quantity through the design of the architecture.


Based on the real-world observation that entities, such as systems and especially
humans, interact with each other in certain spaces or contexts, the Mushu archi-
tecture intends to cover the possibility of these entities to spontaneously create
spaces for communication and interaction on a conceptual level. Agent-oriented
software development provides a solid foundation for this and interprets the en-
tities mentioned as agents. However, the simulation of large systems is no longer
possible or cost-eï¬€icient for single machines above a certain extent. Therefore,
the Mushu architecture was designed with the idea in mind that within a reali-
sation, the overall architecture describes a distributed system and the platforms
are the largest local entities. It is then deduced that the dynamic generation of
platforms by agents can be described as scaling operations from a technical point
of view. On the technical level, the Mushu architecture thus describes different
parts ranging from software components to the deployment landscape.


The last remaining aspect is the mapping of real-world situations to such models.
A viable methodology for this exists in the context of scene analysis, in which hy-
potheses about observed situations are derived from (image) data and contextual
knowledge, in line with the general agent-oriented approach. Since a compre-
hensive consideration of this process would take up the scope of several separate
theses, this thesis only discusses the approach. In doing so, it is explained that
a mapping for large-scale calculations should nevertheless be quick to compute.
In order to make a generalised contribution to this aspect, a heuristic is intro-
duced which is fundamental for the acceleration of a class of pattern recognition
algorithms.


The thesis follows a three-step approach of a conceptualisation, the creation of a
realisation concept and the description of prototypes. In the conceptualisation the
abstract architecture is described, the creation of a realisation concept addresses
the mapping to existing (or to be constructed) kinds of technology, and finally
prototypes apply the realisation concepts to concrete technologies, frameworks,
etc., and also describe the implementations that have taken place within the
context of the thesis.


Danksagung


Mein Dank geht an meinen Betreuer Dr. Daniel Moldt und meine Betreuerin
Prof. Dr. Leonie Dreschler-Fischer fÃ¼r ihre Hilfestellungen im Rahmen der Ar-
beit. Insbesondere durch die Hinweise, die unzÃ¤hligen GesprÃ¤che und gemeinsa-
men Projekte mit Dr. Daniel Moldt und der damit einhergehenden exzellenten
UnterstÃ¼tzung war ich in der Lage die Thematik der Arbeit in dieser Form bear-
beiten zu kÃ¶nnen. DarÃ¼ber hinaus danke ich Prof. Dr. Dreschler-Fischer fÃ¼r die
vielen GesprÃ¤che und die fortlaufende UnterstÃ¼tzung wÃ¤hrend der Arbeit. Fer-
ner gilt mein Dank Prof. Dr. Peter Kling fÃ¼r die Ãœbernahme des Vorsitzes der
PrÃ¼fungskomission, Prof. Dr. Karsten Wolf fÃ¼r die Begutachtung und die Unter-
stÃ¼tzung der PrÃ¼fungskomission, sowie Prof. Dr. Norbert Ritter fÃ¼r die Teilnahme
an der PrÃ¼fungskomission.


Ich mÃ¶chte weiterhin allen Menschen in meiner Familie fÃ¼r die fortlaufende Unter-
stÃ¼tzung wÃ¤hrend der Anfertigung der Dissertation und allen HÃ¶hen und Tiefen
wÃ¤hrend des ganzen Promotionsverfahrens danken. Mein Dank gilt dabei meinen
Eltern Gaby und Claus, meiner Partnerin Manuela und ihrer Mutter Birgit.


Im weiteren Rahmen der UniversitÃ¤t gilt mein Dank allen Dozenten, Doktoran-
den, Postdocs, Kommilitonen und Studierenden, welche Ã¼ber die Jahre meines
Bachelor-, Master- und Promotionsstudiums hilfreiches Feedback geliefert und zu
spannenden Diskussionen beigetragen haben. Insbesondere sind dies (ohne spe-
zifische Reihenfolge): Michael Haustermann, David Mosteller, Dennis Schmitz,
Michael Simon, Dr. Benjamin Seppke, Dr. Thomas Wagner, Prof. Dr. Micha-
el KÃ¶hler-BuÃŸmeier, Eva MÃ¼ller, Dr. Frank Heitmann, Dr. Matthias Wester-
Ebbinghaus, Prof. Dr. RÃ¼diger Valk, Prof. Dr. Peer Stelldinger, Matthias Feld-
mann, Felix Beese, Rainer JÃ¼rgensen, Jan Robert Janneck und Laif-Oke Clasen.
DarÃ¼ber hinaus gilt mein spezieller Dank Marvin Taube, Patrick Mohr, Henri
Engelhardt, Laszlo Korte, Alexander Senger, Sven Willrodt, Laif-Oke Clasen und
Manuela Buchholz fÃ¼r die UnterstÃ¼tzung bei der technischen Implementationsar-
beit im Rahmen dieser Arbeit.


Dann mÃ¶chte ich allen Freunden, Familie und Bekannten danken, die sich die
Zeit genommen haben diese Arbeit korrekturzulesen: Bennet, Jann, Adrian, Kay,
Benni, Peer, Dennis, VoÃŸi, Elly, Gaby, Felix, Laif, JÃ¼rgen, Manuela, Sven und
Thomas. Zuletzt danke ich noch Hanna fÃ¼r die ErmÃ¶glichung Ã¤uÃŸerst flexibler
Arbeitszeiten im letzten Jahr der Anfertigung der Arbeit.


Ausgangspunkt


1. Einleitung


Bei genauer Betrachtung der Welt und der in ihr agierenden Menschen, Syste-
me, Software, Tiere und weiteren sowie deren Umgebungen fÃ¤llt auf, dass sich
bestimmte Strukturen an vielen Orten wiederholen. So kann beispielsweise ein
Austausch zwischen drei alten Freunden in einem CafÃ© stattfinden, ein Mensch
eine Katze streicheln, ein Analytiker die soeben berechneten GeschÃ¤ftszahlen eines
Unternehmens lesen oder aber sich ein Smartphone mit einem Nachrichtenserver
synchronisieren. Diese auf den ersten Blick sehr verschiedenen Situationen haben
jedoch eine gemeinsame Basis. EntitÃ¤ten, die individuell und fÃ¼r sich entscheiden,
planen und handeln, gehen eine gemeinsame Interaktion ein, sie synchronisieren
sich.


Derartige beschriebene Interaktionen finden immer innerhalb eines Kontextes,
bzw. einer RÃ¤umlichkeit statt. So befinden sich die Freunde in einem CafÃ©, der
Mensch mit der Katze beispielsweise im Wohnzimmer seiner Wohnung, der Ana-
lytiker im BÃ¼ro und die Synchronisation zwischen Smartphone und Server gewis-
sermaÃŸen in einem geschlossenen Kommunikationskanal im Netzwerk. In unserer
Umgebung geschehen derartige Prozesse millionenfach und zu jeder denkbaren
Zeit. Sie folgen dabei keiner gemeinsamen globalen Taktung, sondern geschehen
vielfach zeitlich vollstÃ¤ndig unabhÃ¤ngig voneinander, sie geschehen nebenlÃ¤ufig.
Dies bedeutet jedoch keineswegs, dass zwangslÃ¤ufig alle Aktionen unabhÃ¤ngig
voneinander geschehen mÃ¼ssen. So kann der Mensch, der die Katze streichelt,
beispielsweise gleichzeitig noch ein Telefonat fÃ¼hren und auf einen stummgeschal-
teten Fernseher schauen. Einzelne Aktionen kÃ¶nnen sich auch bedingen und somit
in einem Kausalzusammenhang stehen, so kÃ¶nnte das Telefonat aufgrund einer
entsprechenden Nachricht auf dem Smartphone initiiert worden sein. Die verschie-
denen Aktionen kÃ¶nnen sich beliebig Ã¼berlappen.


Jede EntitÃ¤t in diesem globalen System handelt getrieben durch innere Prozesse,
je nach KomplexitÃ¤t basierend auf einer Form der Wissensspeicherung. Sie han-
deln alleine, kÃ¶nnen sich jedoch auch in Kooperation mit anderen begeben, um ge-
meinsam eine Handlung zu vollziehen. Dabei treffen sie an einem physischen oder
virtuellen Ort â€“ oder allgemeiner gesagt â€“ einer Plattform aufeinander. Beispie-
le fÃ¼r eine solche Plattform sind gegeben durch RÃ¤ume, Konferenzen, Telefonate
und viele weitere.


DarÃ¼ber hinaus sind EntitÃ¤ten in der Lage diese Plattformen zu manipulieren,
sie zu erzeugen, zu zerstÃ¶ren bzw. abzubauen und anzupassen. RÃ¤ume kÃ¶nnen
gebaut, Telefonate gestartet, Internetverbindungen hergestellt und Konferenzen
verabredet werden. Die Ã„nderung an Plattformen findet meist indirekt durch
die EntitÃ¤ten statt, so kann z.B. in einem Raum das Licht angeschaltet werden
oder das Routing einer Verbindung geÃ¤ndert werden. Bei grÃ¶ÃŸeren Ã„nderungen
ist meist eine Ã¼bergeordnete Instanz involviert, welche die Plattform bereitstellt,
an die die Anfrage gerichtet werden kann. So kÃ¶nnte ein Unternehmen die kon-
krete Ausrichtung einer Abteilung Ã¤ndern oder durch den GebÃ¤udeverwalter eine
technische Ausstattung in einem Raum installiert werden. Als Beispiele fÃ¼r die
ZerstÃ¶rung von RÃ¤umen kann die Beendigung eines Telefonates, das Ende einer
Konferenz, der Abriss eines GebÃ¤udes und weitere genannt werden.


Wenn die Idee der EntitÃ¤ten und Plattformen weiter abstrahiert wird, kÃ¶nnen in
bestimmten FÃ¤llen Plattformen wiederum mit anderen Plattformen kooperieren
und sich somit selbst wie EntitÃ¤ten verhalten. Reale Beispiele sind Abteilungen
in einem Unternehmen oder gemeinsam ausgerichtete Konferenzen.


Eine der groÃŸen Erleichterungen durch die Informatik besteht darin durch Simu-
lationen bereits im Vorfeld Aussagen Ã¼ber Verhalten unter bestimmten Parame-
tern treffen zu kÃ¶nnen. Von dieser Technologie profitieren tÃ¤glich Milliarden von
Menschen, sei es durch berechnete Wettervorhersagen, BahnfahrplÃ¤ne oder Ver-
kehrsplanung um beispielsweise Ampelschaltungen zu optimieren. HÃ¤ufig existiert
zu jedem speziellen Anwendungsfall eine sehr spezialisierte Simulationssoftware,
die mit groÃŸer PrÃ¤zision versucht die DomÃ¤ne eines spezifischen Problems abzu-
bilden. Simulationen, die allerdings generalisierte Informationen und Vorhersagen
zulassen, sind seltener anzutreffen.


FÃ¼r Simulationen ist es stets sinnvoll ein geeignetes Modell der zu simulieren-
den Systeme zu erzeugen. Die modellgetriebene Softwareentwicklung ist eines der
Resultate aus diesem Umstand. FÃ¼r die Ableitung von Modellen aus der realen
Welt existieren verschiedene Herangehensweisen. Eine mÃ¶gliche dieser Herange-
hensweisen ist die Szenenanalyse, welche ihrerseits wieder eine Unterkategorie
der Bild(folgen)verarbeitung ist. Die Szenenanalyse beschÃ¤ftigt sich mit der Ex-
traktion von Hypothesen aus Bildfolgen auf der Basis von Bildinformationen und
Kontextwissen. Dabei sind die Hypothesen auf hÃ¶herer Ebene zu verorten als
einfache Bilddaten. So sind beabsichtigte Ergebnisse beispielsweise die Differen-
zierung zwischen einem Tanz und einem Handgemenge. Je genauer das extrahierte
Modell der zugehÃ¶rigen Welt ausfÃ¤llt, desto detailliertere Hypothesen kÃ¶nnen ex-
trahiert werden.


Trotz der offensichtlichen ZusammenhÃ¤nge zwischen nebenlÃ¤ufigen Handlungen,
groÃŸer Anzahl der EntitÃ¤ten und der MÃ¶glichkeit die eigene Laufzeitumgebung an-
zupassen und zu Ã¤ndern, existieren jedoch bislang wenige Softwarearchitekturen,
welche diese Anforderungen umfassend in einem System in Einklang bringen und


eine ausreichende Basis liefern, um daraus Ableitungen zu ermÃ¶glichen. Dies ist in
erster Linie der hohen KomplexitÃ¤t der Kombination der einzelnen Bestandteile
geschuldet. WeiterfÃ¼hrende Argumentationen zu dieser These werden in Kapitel 4
gefÃ¼hrt.


Da somit noch grundlegende Fragen fÃ¼r die Modellierung dieses VerstÃ¤ndnisses
von RealweltablÃ¤ufen fÃ¼r die Interpretation im Rahmen der Szenenanalyse unge-
klÃ¤rt sind, adressiert diese Arbeit die Schaffung einer entsprechenden architektu-
rellen Grundlage. Diese kann sodann sowohl in der Szenenanalyse, aber auch in
anderen Anwendungsszenarien eingesetzt werden. Beispielhafte Anwendungssze-
narien jenseits der Szenenanalyse werden in Abschnitt 1.2 noch einmal genauer
ausgefÃ¼hrt.


Zur Bearbeitung der Aufgabe ist es zunÃ¤chst angebracht einen entsprechenden
Grundansatz der Softwarearchitektur zu betrachten. Die agentenorientierte Soft-
wareentwicklung ist dabei hervorragend geeignet, da sie den sogenannten Soft-
wareagenten autonome Eigenschaften zugesteht. Die Definition eines Software-
agenten ist durch die Literatur hinweg nicht eindeutig, meist wird damit jedoch
ein gewisses MaÃŸ an Autonomie, Zielorientierung, InteraktionsvermÃ¶gen und Wis-
sen verbunden. Eine genauere Definition des Begriffes fÃ¼r diese Arbeit folgt in Ka-
pitel 2. Diese Grundeigenschaften machen Agenten zu einem guten Ansatz, um
interagierende EntitÃ¤ten zu modellieren. Folglich bezieht sich diese Arbeit auf das
Paradigma der agentenorientierten Softwareentwicklung.


Um den Ansatz weiter eingrenzen und zielgerichteter bearbeiten zu kÃ¶nnen, wer-
den im Rahmen der Arbeit Agenten im Sinne des Mulan Modells (RÃ¶lke, 2004)
und dessen Erweiterungen betrachtet. Sie entsprechen damit nach und analog
zu (Wagner, 2018) dem Agentenbegriff aus (Wooldridge, 2009, S.26-27). Da-
mit einhergehend umfasst das betrachtete Agentenmodell keine kognitiven Kon-
zepte oder solche, welche kÃ¼nstlicher Intelligenz entsprechen wÃ¼rden. Insbesondere
Agenten nach dem BDI-Ansatz (Â»BelieveÂ«, Â»DesireÂ«, Â»IntentionÂ«) (Bratman,
1987; Rao und Georgeff, 1991) und Verwandte sind damit auÃŸerhalb des Um-
fangs der Arbeit, wenngleich sich die BDI-Konzepte und die Intelligenz in Mulan
konzeptionell gut eingliedern (RÃ¶lke, 2004).


Zahlreiche andere Arbeiten setzen bereits auf dem Mulan-Ansatz auf, wie bei-
spielsweise (Reese, 2009), (Wester-Ebbinghaus, 2010), (Cabac, 2010), (Wag-
ner, 2018) und weitere. Analog zu diesen Publikationen setzt auch diese Arbeit
als Modellierungstechnik Petrinetze und im speziellen Referenznetze (Kummer,
2002) ein.


Petrinetze eignen sich hervorragend als Modellierungswerkzeug fÃ¼r nebenlÃ¤ufige
Systeme und auch verteilte Systeme. Durch ihre strikte Trennung von aktiven und
passiven Komponenten und auch durch die Grundidee der Marken sind sie in der
Lage, Ressourcen und AblÃ¤ufe prÃ¤gnant zu modellieren. Petrinetze untergliedern


sich in eine Vielzahl verschiedener Formalismen, bei denen die Referenznetze in-
nerhalb dieser Arbeit eine gesonderte Stellung einnehmen. Je nach Kontext bzw.
Bedarf oder VermÃ¶gen der Werkzeuge kÃ¶nnen verschiedene Semantiken wie die
(echte) NebenlÃ¤ufigkeit (Petri, 1962), die Schritt- oder Interleaving-Semantik
zur Simulation von Petrinetzen zum Einsatz kommen.


Referenznetze gehÃ¶ren den Objektnetzen an, basieren auf Netzen-in-Netzen (Valk,
1998) und integrieren objektorientierte Netze (Moldt, 1996) und synchrone Ka-
nÃ¤le (J. Christensen, 1994). ZugehÃ¶rige formale Arbeiten bestehen durch (KÃ¶h-
ler, 2004) und (Heitmann, 2013). Weitere BeitrÃ¤ge zum Thema Objektnetze
umfassen beispielsweise die Publikationen (Buchs, Flumet und Racloz, 1992;
Lakos, 1995; Buchs und Guelfi, 2000; Farwer und I. Lomazova, 2001; Irina
Lomazova und Ermakova, 2016). Referenznetze kÃ¶nnen auf einfache Art und
Weise inhÃ¤rent hierarchische, nebenlÃ¤ufige Systeme kompakt modellieren. Eben
diese Art von Systemen stellen Agenten, welche auf Plattformen miteinander in-
teragieren, dar.


WÃ¤hrend Petrinetze einen formalen Rahmen vorgeben und viele Beweise und
AnsÃ¤tze der Verifikation fÃ¼r einfache Klassen der Petrinetze bestehen, sind sol-
che Verfahren bei Referenznetzen Gegenstand aktueller Forschung. Entsprechende
Grundlagen wurden bereits in den Arbeiten Kummers (Kummer, 2002) auf der
Basis von Graphtransformationssystemen und weiteren formalen HintergrÃ¼nden
geschaffen. Aktuellere Arbeiten umfassen beispielsweise die BeitrÃ¤ge (Willrodt,
2019), (Willrodt, Moldt und M. Simon, 2020) und (Engelhardt, 2020).
Entsprechende Untersuchungen bildeten die Grundlage der Implementation des
Referenznetzsimulators Renew (Kummer und Wienberg, 1999b; Kummer,
Wienberg, Duvigneau, Cabac u. a., 2020a), in dessen Kontext auch eine tech-
nische Implementation der Mulan-Architektur erfolgte. Deshalb und da die Un-
tersuchungen aktuell aktiv vorangetrieben werden, wird argumentiert, dass der
fehlende umfassende formale Rahmen von Mulan und von Referenznetzen in
Kauf genommen werden kann, um das Grundmodell der Referenznetze und ihren
hierarchischen Modellierungseigenschaften dennoch einsetzen zu kÃ¶nnen. Dies gilt
insbesondere, wenn es sich um praktische und angewandte Modellierung handelt.
Ferner sind aus diesem Grund AnsÃ¤tze formaler Verifikation und Ã¤hnliches nicht
Teil des Umfangs dieser Arbeit.


Der Petri net-based, Agent- and Organization-Oriented Software
Engineering(Paose)-Ansatz nach (Moldt, 2005) (Cabac, DÃ¶rges, Duvi-
gneau, Moldt u. a., 2008) (Cabac, 2010) erweitert das VerstÃ¤ndnis des Agen-
tensystems auf die Entwicklung derartiger Multiagentensysteme und etabliert es
als Ã¼bergreifendes Leitbild (Cabac, 2007). Der Paose-Ansatz ist zugeschnitten
auf die Entwicklung im Capa-Umfeld (Concurrent Agent Platform Ar-
chitecture) (Duvigneau, 2002), (Duvigneau, Moldt und RÃ¶lke, 2002),


(Duvigneau, Moldt und RÃ¶lke, 2003), wobei Capa eine FIPA1-konforme spe-
zifische Implementation von Mulan darstellt. Paose selbst ist auch allgemeiner
einsetzbar. Capa wird im Rahmen der Arbeit zwar referenziert, dient jedoch nicht
als direkte Grundlage. Das generelle Verfahren in der Erstellung der Arbeit ist an
den Paose-Ansatz angelehnt, setzt ihn aber nicht vollumfÃ¤nglich um, da die Ar-
beit lediglich Ãœberschneidungen mit dem Rahmen von Capa aufweist. Einzelne
Artefakte wie beispielsweise Agenteninteraktionsprotokolle (AIPs) zur Beschrei-
bung von Teilsystemen und AblÃ¤ufen kommen aber dennoch zum Einsatz. Umge-
kehrt stellt diese Arbeit jedoch in Hinblick auf eine konzeptionelle und software-
technische ergÃ¤nzende Verbesserung der Modellierung, Verteilung und Nutzung
einen Beitrag zur Erweiterung des Paose-Ansatzes dar.


Eine Besonderheit in der Simulation derartiger agentenorientierter Systeme im
Kontext der Szenenanalyse ist der Umstand, dass Algorithmen im direkten Be-
reich der Bildverarbeitung meist entweder auf reine Umsetzbarkeit untersucht
werden oder aber den harschen Anforderungen einer Echtzeitanwendung unter-
liegen. Beide AnsÃ¤tze sind unglÃ¼cklich fÃ¼r den hier intendierten Einsatzzweck
der Abbildung und Simulation realer Prozesse. ÃœbermÃ¤ÃŸig langsame Algorith-
men bremsen die Simulation aus und Echtzeitalgorithmen bringen grÃ¶ÃŸere Opfer
als es fÃ¼r den Kontext notwendig wÃ¤re.


1.1. Ziele der Arbeit und Forschungsfragen


WÃ¤hrend viele der im vergangenen Abschnitt angesprochenen Bereiche interes-
sante Untersuchungsfelder darstellen kÃ¶nnen, ist jedoch der Umfang einer jeden
Arbeit auf ein spezifisches Thema eingegrenzt. FÃ¼r diese Arbeit wird daher im
Kontext der bisherigen AusfÃ¼hrungen zu interagierenden Agenten und deren Wir-
kung auf die Plattformen, auf denen sie interagieren, und insbesondere die Er-
zeugung und ZerstÃ¶rung dieser Plattformen durch die Agenten, die folgende For-
schungsfrage gestellt:


Wie kÃ¶nnen, entsprechend realweltlichen Interaktionen, nebenlÃ¤ufige,
interagierende Agenten mit Einfluss auf die Plattformen, auf denen ihre
Interaktion stattfindet, sowie auf deren Gesamtmenge als Modell bzw.
Architektur eines verteilten Systems, beschrieben werden?


Die Forschungsfrage umfasst damit zwei Hauptbestandteile: Den Einfluss von
Agenten auf die Plattform sowie den Einfluss der Agenten auf die Skalierung der
Menge der verfÃ¼gbaren Plattformen.


1Foundation for Intelligent Physical Agents


WÃ¤hrend der erste Teil im Kern die Interaktion und dynamische Modifikation
einer einzelnen Plattform betrifft, adressiert der zweite Teil die Interaktion und
dynamische Modifikation der Gesamtmenge der Plattformen. Die Dynamisierung
der Plattformen fÃ¼hrt jedoch unweigerlich zu potentiell problematischer Kommu-
nikation zwischen Agenten. Plattformen kÃ¶nnten durch Skalierungsoperationen
temporÃ¤r oder permanent verloren gehen. Die klassischen AnsÃ¤tze fÃ¼r Kommuni-
kation (Nachrichtenzustellung) in verteilten Multiagentensystemen kÃ¶nnten dabei
auf Probleme stoÃŸen. Dies betrifft insbesondere Interaktionen, welche auf bilate-
ralem Informationsaustausch basieren, da hierbei meist eine gewisse Form der
Garantie fÃ¼r Zustellungsoperationen nÃ¶tig ist.


Aus diesen Herleitungen soll daher die zweite betrachtete Forschungsfrage lauten:


Wie kann eine nebenlÃ¤ufige bilaterale Kommunikation zwischen Agenten
gewÃ¤hrleistet werden, wenn ihre Plattformen zur Interaktion potentiell flÃ¼chtige
EntitÃ¤ten sind?


Trotz der natÃ¼rlichen Relevanz der Forschungsfragen existieren â€“ wie sich in Ab-
schnitt 4.3.4 zeigen wird â€“ bisher nur unzureichende LÃ¶sungen. Auf die Relevanz
wird in Abschnitt 1.2 noch weiterfÃ¼hrend eingegangen. Existierende LÃ¶sungen de-
cken zumeist wenigstens einen der betrachteten Aspekte nicht ab: Modellbasierte
Entwicklung, echte NebenlÃ¤ufigkeit, Autonomie der EntitÃ¤ten, Einfluss der Enti-
tÃ¤ten auf Plattformen oder die Modellierung von lokalen und verteilten Anteilen
des Systems. Weitere Informationen zu dieser Aussage werden in Kapitel 3 zum
Stand der Forschung sowie in Kapitel 4 zur Anforderungsanalyse aufgearbeitet.


Um mÃ¶glichst universell einsatzfÃ¤hig zu sein, sollte das Architekturkonzept der
Forschungsfragen mÃ¶glichst abstrakt gehalten werden und nicht auf konkrete tech-
nische LÃ¶sungen eingehen. Eine Umsetzung einer entsprechenden Architektur, wie
sie von den Forschungsfragen gefordert wird, umfasst zwangslÃ¤ufig den Einsatz
mehrerer physikalischer Recheneinheiten und damit die Konstruktion eines ver-
teilten Systems. Die Konstruktion verteilter Systeme ist im besonderen MaÃŸe an-
spruchsvoll. Unter diesem Aspekt ist es daher angebracht neben dem abstrakten
Architekturkonzept ebenso ein Realisierungskonzept vorzustellen, welches als Bin-
deglied zwischen technischer Implementation und abstrakter Spezifikation dient.
Auf Basis des Realisierungskonzepts kÃ¶nnen dann Proof-of-Concept Implementa-
tionen (Prototypen) erfolgen. Die Gliederung der Arbeit folgt diesen Ãœberlegun-
gen. Eine genaue Ãœbersicht erfolgt am Ende der Einleitung in Abschnitt 1.3.


Jenseits der direkten Anforderungen der aufgestellten Forschungsfragen wurde be-
reits motiviert, dass die moderate Beschleunigung von Bildverarbeitungsprozessen
ein wenig untersuchtes Feld ist. Aus diesem Grund soll eine weitere Forschungs-
frage angeschlossen werden, welche sich jedoch nur im Kontext der Anwendungs-
domÃ¤ne der Szenenanalyse formulieren lÃ¤sst:


Ist es mÃ¶glich, fÃ¼r einige Bildverarbeitungsalgorithmen grundlegende und
beschleunigende Heuristiken zu definieren, deren Leistung zwischen reiner
Umsetzbarkeit der Aufgabe und den Anforderungen einer Echtzeitanwendung
liegt?


1.2. Anwendungsbeispiele


Die generelle Abbildung der Forschungsfragen auf realweltliche ZusammenhÃ¤nge
wurde bereits in den vergangenen Abschnitten erlÃ¤utert. Dennoch ist zur Illus-
tration die Darstellung entsprechender realweltlicher Beispiele hilfreich. Um zu
motivieren, wie ein Ergebnis in diesem Bereich bedeutsame Verbesserungen mit
sich ziehen kann, werden im Folgenden einige Anwendungsszenarien umrissen.


Krankheitsstand ausgleichen In diesem Szenario kÃ¶nnen Mitarbeiter fÃ¼r andere,
erkrankte Mitarbeiter einspringen und deren Aufgaben Ã¼bernehmen. Dabei
sind die FÃ¤higkeiten der Vertretung bezogen auf die Ã¼bernommene Aufga-
be jedoch nicht so stark ausgeprÃ¤gt wie bei dem ausgefallenen Mitarbei-
ter. Die Arbeit erfordert den Austausch mit Kollegen und die Interaktion
mit der ArbeitsstÃ¤tte. Neben den weitestgehend festen ArbeitsstÃ¤tten in-
teragieren Kollegen auch miteinander und schaffen sich zu diesem Zweck
dynamisch Plattformen wie Telefonverbindungen oder Meetings. Bei grÃ¶ÃŸe-
ren Unternehmen ist eine Kooperation verschiedener ArbeitsstÃ¤tten denkbar
(FertigungsstraÃŸen). Mit einem Modell der Belegschaft und den ArbeitsstÃ¤t-
ten kÃ¶nnten verschiedene Vertretungs-Szenarien exploriert werden, um gute
LÃ¶sungen fÃ¼r die VertretungsplÃ¤ne vorauszuberechnen. Als weitere unter-
suchbare Eigenschaften in der Simulation sind Verletzungsrisiken, soziale
Dynamiken zwischen den Mitarbeitern, Zufriedenheit und andere denkbar.


Kooperierende Roboter Hierbei werden mehrere autonome kooperierende Ro-
boter betrachtet. Dabei kann die Aufgabenstellung vielfÃ¤ltig sein. So kÃ¶nnte
ein Roboter Waren aus einem Lagerregal heben und einem zweiten Roboter
zielsicher Ã¼bergeben, sodass letzterer diese dann zur Versandstation bringt,
wo er mit einem weiteren Roboter kooperiert. FÃ¼r Interaktionen erzeugen
oder nutzen die Roboter dynamisch Plattformen wie RÃ¤ume oder den Auf-
bau einer Verbindung mit einer Kommunikationstechnologie.


Verkehrsfluss Eine andere Anwendung sind in diesem Kontext Kraftfahrzeuge
auf der StraÃŸe. Durch die Kooperation der einzelnen Individualfahrzeu-
ge entsteht ein globaler Verkehrsfluss. Durch eine skalierbare Simulation
der Situation kÃ¶nnen Verkehrsdichten vorausberechnet werden, wÃ¤hrend
auf den individuellen Charakter der Einzelfahrzeuge eingegangen werden
kann. Klassische Verkehrssimulationen sind gezwungen an dieser Stelle auf


Vereinfachungen wie die Aufgabe der Modellierung inidividueller Verkehrs-
teilnehmer zurÃ¼ckzugreifen, um die Geschehnisse in Ã¼berschaubare mathe-
matische Formeln zu Ã¼berfÃ¼hren. Auch Ã„nderungen an der StraÃŸenfÃ¼hrung
wÃ¤ren denkbar durch die MÃ¶glichkeit der Agenten Einfluss auf die Platt-
form zu nehmen. So wÃ¤ren dynamische Anpassungen im Modell mÃ¶glich.
Entsprechende Modelle kÃ¶nnen durch Verkehrskameras oder Fahrzeuge mit
entsprechenden Sensoren auf der Basis der Szenenanalyse unterstÃ¼tzt wer-
den, um bestimmte Situationen zu erkennen.


Balancierung von Gesellschafts- oder Onlinespielen Kompetitive Spiele erhal-
ten ihre Spannung dadurch, dass die Chancen der Spielteilnehmer ausgegli-
chen sind, egal mit welchen der auswÃ¤hlbaren Startbedingungen sie jeweils
beginnen. Die Balancierung von Spielen ist in sich keine leichte Aufgabe;
eine Vorhersage zu treffen, welche AusprÃ¤gung die Gesamtheit der (spÃ¤te-
ren) Spieler haben wird, ist Ã¤uÃŸert schwierig. Durch die Modellierung der
interagierenden Spieler und der Codierung der Spielregeln kann durch eine
agentenorientierte Simulation jedoch darÃ¼ber eine Aussage getroffen wer-
den, indem die SimulationslÃ¤ufe in Bezug auf GewinnhÃ¤ufigkeit analysiert
werden. Durch die dynamische Erzeugung von Plattformen kÃ¶nnen Kom-
munikationen im und neben dem Spiel modelliert werden.


Simulation von MÃ¤rkten MÃ¤rkte sind komplexe Systeme mit vielen autonom
agierenden Teilnehmern. Handel kann zwischen verschiedenen Teilnehmern
auf unterschiedlichen (Handels)plattformen stattfinden, Teilnehmer kÃ¶n-
nen in direkten Austausch treten und (Handels)plattformen weisen unter-
schiedliche AusprÃ¤gungen aus. Mit der Modellierung entsprechender Agen-
ten kÃ¶nnten sich mit Simulationen Vorhersagen Ã¼ber Marktverhalten treffen
lassen. Die Hauptschwierigkeit besteht selbstverstÃ¤ndlich in der korrekten
Modellierung der Agenten und ihrer jeweiligen Verhaltensmuster. Mit einer
Architektur, wie sie in dieser Arbeit angestrebt wird, wÃ¤re ein konkreter
Rahmen und eine RealisierungsmÃ¶glichkeit einer naturgetreuen Abbildung
geschaffen.


Allen Beispielen ist gemein, dass die ErschlieÃŸung neuer KommunikationskanÃ¤le
bzw. Plattformen der abgebildeten EntitÃ¤ten maÃŸgeblichen Einfluss auf die je-
weils skizzierte Simulation hat. Auch die FlÃ¼chtigkeit dieser Plattformen spielt
eine entscheidende Rolle bei dem Verlauf der Simulation. Mit dem Bestehen ei-
ner entsprechenden Architektur, welche diese Eigenschaften adressiert, kÃ¶nnte ein
Beitrag fÃ¼r die genannten Anwendungsszenarien geleistet werden.


1.3. Aufbau der Arbeit


Die Arbeit gliedert sich in fÃ¼nf Hauptbestandteile. Teil I fÃ¼hrt in Kapitel 2 zu-
nÃ¤chst die notwendigen Grundlagen ein, um eine Diskussion bestehender LÃ¶sun-
gen zu ermÃ¶glichen. In Kapitel 3 werden danach bestehende LÃ¶sungen und be-
reits im erweiterten Kontext der Forschungsfragen erfolgte Forschung diskutiert.
Kapitel 4 analysiert und evaluiert diese LÃ¶sungen insbesondere im Kontext der
Forschungsfragen und zeigt nÃ¶tige Arbeiten fÃ¼r die Beantwortung der Forschungs-
fragen auf. Ferner wird dabei das generelle Vorgehen hierzu ausgefÃ¼hrt.


AnschlieÃŸend widmet sich Teil II der konzeptuellen Aufarbeitung einer Architek-
tur fÃ¼r interagierende Agenten mit Einfluss auf die Skalierung ihrer Plattform-
menge. Entlang der Forschungsfragen adressiert Kapitel 5 die Kommunikation
zwischen Agenten, Kapitel 6 die Interaktion mit der Plattform durch Agenten
und Kapitel 7 konzipiert eine Verwaltungsebene fÃ¼r Plattformen selbst. Abschlie-
ÃŸend fasst Kapitel 8 die Ergebnisse in eine kombinierte Architektur zusammen.


Ausgehend von der in Kapitel 8 zusammengefÃ¼gten Architektur beschreibt Teil III
eine Abbildung der abstrakten Architektur auf verschiedene Bausteine und Sys-
temkomponenten in der Form von Realisierungskonzepten. Ein Realisierungskon-
zept ist dabei nicht als Pflichtenheft der Wasserfall-Softwareentwicklung zu ver-
stehen, sondern als konzeptuelle Zusammenstellung verschiedener technologischer
LÃ¶sungsansÃ¤tze mit dem Ziel der Umsetzung der Architektur. Dabei wird eine et-
was niedrigere Abstraktionsebene eingenommen und der Einsatz von Renew als
Referenznetzsimulator vorgegeben, jedoch darÃ¼ber hinaus keine EinschrÃ¤nkung
auf konkrete Technologien vorgenommen. Kapitel 9 erÃ¶rtert zunÃ¤chst die techni-
schen Rahmenbedingungen bestehender LÃ¶sungen und AnknÃ¼pfungspunkte. Auf
dieser Basis diskutiert Kapitel 10 eine mÃ¶gliche Realisierung der Verwaltungsebe-
ne von Plattformen, Kapitel 11 die Realisierung einer entsprechenden Schnittstelle
zu Plattformen und Kapitel 12 eine mÃ¶gliche Umsetzung der Agentenkommuni-
kation. Zuletzt adressiert Kapitel 13 die letzte Forschungsfrage im Kontext der
AnwendungsdomÃ¤ne der Szenenanalyse. Das Ziel hierbei ist eine grundlegende
und beschleunigende Heuristik fÃ¼r hÃ¤ufig in dem Kontext eingesetzte Algorith-
men.


AbschlieÃŸend widmet sich Teil IV der Evaluation der Untersuchungen. In Kapi-
tel 14 folgt eine Beschreibung konkreter Prototypen und Implementationen im
Rahmen der Arbeit. Dabei handelt es sich um konkrete technische Ausgestal-
tung der Realisierungskonzepte (oder VorlÃ¤ufer davon) aus Teil III. AnschlieÃŸend
evaluiert Kapitel 15 die Ergebnisse der Arbeit bezogen auf die Forschungsfragen.


Im letzten Teil V folgt in Kapitel 16 eine Gesamtzusammenfassung der Arbeit und
Kapitel 17 wirft neben einem Gesamtfazit einen Blick auf mÃ¶gliche zukÃ¼nftige und
anschlieÃŸende Arbeiten.


2. Grundlagen


ZunÃ¤chst soll eine Orientierung der mÃ¶glichen UmsetzungsmÃ¶glichkeiten der Fra-
gestellung erfolgen. Dabei werden verschiedene Vorarbeiten beleuchtet und vor-
gestellt. Das Ziel dieses Kapitels umfasst die Bereitstellung eines grundlegenden
Rahmens fÃ¼r die Analyse und Beurteilung bestehender Arbeiten im Kontext der
Forschungsfragen sowie darin die Basis fÃ¼r die darauf folgenden Teile der Arbeit
zu schaffen. Dieses Kapitel enthÃ¤lt keine Neuentwicklungen des Autors, sondern
lediglich eine Aufarbeitung von Vorarbeiten fÃ¼r einen generellen Kontext der Ar-
beit.


2.1. NebenlÃ¤ufigkeit, Modelle und Simulationen


ZunÃ¤chst sollen einige der zentralen Begriffe der Arbeit eingefÃ¼hrt werden. Dabei
handelt es sich um den Begriff der NebenlÃ¤ufigkeit, des Modells und der Simulati-
on. Diese sind erforderlich, um weitere darauf aufbauende Konzepte zu erÃ¶rtern.


2.1.1. NebenlÃ¤ufigkeit und ParallelitÃ¤t


Im Laufe der Arbeit werden die Begriffe Â»NebenlÃ¤ufigkeitÂ« und Â»ParallelitÃ¤tÂ«
hÃ¤ufig fallen. In vielen Referenzen werden die beiden Begriffe synonym verwendet.
WÃ¤hrend dies in vielen Situationen sinnvoll ist, sollen beide Begriffe im Rahmen
dieser Arbeit unterschiedliche Konzepte beschreiben. Die NebenlÃ¤ufigkeit wird im
Sinne der NebenlÃ¤ufigkeitstheorie Petris verstanden (Petri, 1962).


Intuitiv beschreiben beide Begriffe zwei Ereignisse, welche gemeinsame voraus-
gehende Ereignisse und/oder gemeinsame nachfolgende Ereignisse besitzen oder
aber in keinerlei derartiger Beziehung stehen und sich selbst gegenseitig nicht in
eine zeitliche Abfolge oder in Reihenfolge bringen lassen. ParallelitÃ¤t sieht dabei
jedoch einen globalen Takt bzw. Schrittgeber vor, sodass Ereignisse in diskreten,
gleichen Takten (Schritten) auftreten kÃ¶nnen. NebenlÃ¤ufigkeit hingegen sieht diese
Form von Taktung nicht vor, sodass nebenlÃ¤ufige Ereignisse gÃ¤nzlich unvergleich-
bar sind. NebenlÃ¤ufigkeit wird im Rahmen der Arbeit gelegentlich auch als Â»echte
NebenlÃ¤ufigkeitÂ« bezeichnet, um gesondert auf diesen Umstand hinzuweisen. Ech-


te NebenlÃ¤ufigkeit und NebenlÃ¤ufigkeit bezeichnen im Rahmen der Arbeit jedoch
ein und dasselbe Konzept.


Beispiele fÃ¼r ParallelitÃ¤t sind hÃ¤ufig anzutreffen, insbesondere in verteilten Syste-
men kommt ParallelitÃ¤t hÃ¤ufig in der Form von Nachrichtenrunden zum Einsatz.
Auch ein zentraler Taktgeber fÃ¼r Arbeitsschritte in einem Prozessor oder einem
verteilten System entspricht dem Ansatz der ParallelitÃ¤t. WÃ¤hrend ParallelitÃ¤t
die zeitliche Abfolge diskretisiert und diese somit deutlich leichter handhabbar
macht, wirkt die Abbildung von Realweltinteraktionen darauf wenig realistisch.


Konversationen und weitere Interaktionen aller EntitÃ¤ten der Welt unterliegen
keiner globalen Taktung. Aus diesem Grund soll im Rahmen dieser Arbeit das
Konzept der NebenlÃ¤ufigkeit eine federfÃ¼hrende Rolle einnehmen.


2.1.2. Modell


Durch den Einsatz von NebenlÃ¤ufigkeit ist eine formal mathematische Beschrei-
bung komplexer Systeme schwierig. Um die umfassenden Untersuchungen fÃ¼r den
Rahmen einer einzelnen Arbeit handhabbar zu erhalten, soll innerhalb der Arbeit
ein modell- und simulationsgetriebener Ansatz verfolgt werden. Zu diesem Zweck
soll zunÃ¤chst der Modellbegriff definiert werden.


Stachowiak definiert Modelleigenschaften hierbei beispielsweise wie folgt:


(Stachowiak, 1973, Seiten 131-133)


FÃ¼r die ReprÃ¤sentation der im einleitenden Teil der Arbeit beschriebenen Kom-
munikationen bilden Modelle die Abbildung der Kommunikationsteilnehmer sowie
der Plattformen der Kommunikation auf verarbeitbare Konzepte. Diese Modelle
sollen so konstruiert sein, dass Ã¼ber sie RÃ¼ckschlÃ¼sse auf reale ZusammenhÃ¤nge
mÃ¶glich sind.


2.1.3. Simulation


Die Â»SimulationÂ« bezeichnet eine Nachahmung bzw. Nachbildung realtweltlicher
Systeme und ZusammenhÃ¤nge. GewÃ¶hnlich basiert sie auf einem Modell und ahmt
die AusfÃ¼hrung bestimmter Interaktionen der Komponenten des Modells nach.


Oberkampf und Roy definieren:


Simulation: the exercise or use of a model to produce a result.
(dt.: Simulation: Die AusÃ¼bung oder Verwendung eines Modells,
um ein Ergebnis zu erzielen.)
â€” (Oberkampf und Roy, 2010, Seite 92)


Dementsprechend soll auch der Simulationsbegriff im Rahmen der Arbeit verstan-
den werden.


Eine besondere Form der Simulation soll an dieser Stelle noch eingefÃ¼hrt werden.
WÃ¤hrend Simulationen eingesetzt werden kÃ¶nnen, um verteilte Systeme zu simu-
lieren, findet in vielen FÃ¤llen die Simulationen der Systeme selbst wiederum lokal
und unverteilt statt. Die Sinnhaftigkeit dieses Vorgangs wird aus den oben ge-
nannten Definitionen von Modell und Simulation ersichtlich: Aus der Simulation
sollen RÃ¼ckschlÃ¼sse auf das Verhalten des simulierten Systems ermÃ¶glicht werden.
Hierzu ist eine echte Verteilung nicht immer unbedingt nÃ¶tig. Die Verteilung kann
ebenfalls simuliert werden.


In FÃ¤llen groÃŸer Simulationen genÃ¼gen einzelne Rechner jedoch unter UmstÃ¤nden
nicht oder erzeugen unverhÃ¤ltnismÃ¤ÃŸig hohe Kosten. Unter UmstÃ¤nden lassen sich
Aspekte der Verteilung jedoch auch nur unzureichend simulieren. In diesem Fall
ist es sinnvoll die Simulation selbst ebenfalls verteilt auszufÃ¼hren; es ist die Rede
von verteilter Simulation verteilter Systeme. Die Schnitte zwischen verschiedenen
lokalen Einheiten der Simulation kÃ¶nnen sich dabei an den Schnitten des Originals
orientieren, mÃ¼ssen dies jedoch nicht zwangslÃ¤ufig. Entlang der Argumentation
verteilte Systeme auch lokal simulieren zu kÃ¶nnen, liegt es hÃ¤ufig nahe, mehr
Operationen lokal auszufÃ¼hren als es im Original der Fall wÃ¤re, da wie beschrieben
ein Modell einen Ausschnitt des Originals abbildet.


Diese Arbeit beschÃ¤ftigt sich im Wesentlichen mit der verteilten Simulation ver-
teilter Systeme.


2.2. Petrinetze


Petrinetze sind eine Modellierungstechnik fÃ¼r nebenlÃ¤ufige Prozesse (Petri, 1962,
1977, 1987). HÃ¤ufig wird bei Modellierungsaufgaben die Unified Modeling Lan-


guage$$$1$$$ (UML; dt. Vereinheitlichte Modellierungssprache) eingesetzt. Neben ihren
StÃ¤rken liefert sie jedoch keine formale Fundierung und auch keine operationale
Semantik. Ebenso ist keine interaktive Simulation auf der Basis von UML mÃ¶glich.
Aus diesem Grund wird argumentiert, dass Petrinetze als Modellierungstechnik
besser fÃ¼r den Kontext dieser Arbeit geeignet sind als die UML.


Die folgenden AusfÃ¼hrungen richten sich im Wesentlichen nach der Beschreibung
von Petrinetzen in (Girault und Valk, 2003). Petrinetze kÃ¶nnen das Erzeugen
und Verbrauchen von Ressourcen modellieren und werden meist als bipartiter, ge-
richteter Graph dargestellt, bestehend aus den disjunkten Mengen der PlÃ¤tze und
der Transitionen. Im Laufe der Arbeit werden Petrinetze auch verkÃ¼rzt nur als
Netze bezeichnet. In PlÃ¤tzen kÃ¶nnen Marken existieren, wobei die Gesamtmenge
aller vorhandenen Marken in allen PlÃ¤tzen den aktuellen Zustand des Systems be-
schreibt. Transitionen kÃ¶nnen Marken von PlÃ¤tzen abziehen und Marken in ihnen
ablegen. Diese Aktion wird gemeinhin als das Feuern oder Schalten einer Transiti-
on bezeichnet. Durch wiederholtes (nebenlÃ¤ufiges) Feuern von Transitionen kann
eine Simulation des durch das Petrinetz abgebildeten Modells erfolgen.


Eine fundamentale Eigenschaft von Petrinetzen ist die NebenlÃ¤ufigkeit, welche
besagt, dass verschiedene Transitionen in einem Netz in vollstÃ¤ndiger zeitlicher
UnabhÃ¤ngigkeit voneinander feuern kÃ¶nnen, sofern genug Marken zur VerfÃ¼gung
stehen. Selbst ein und dieselbe Transition kann nebenlÃ¤ufig zu sich selbst feuern.


An dieser Stelle sei erneut auf den Unterschied zwischen NebenlÃ¤ufigkeit und Par-
allelitÃ¤t hingewiesen, welcher in Abschnitt 2.1.1 eingefÃ¼hrt wurde und so durchweg
in dieser Arbeit Verwendung findet. ParallelitÃ¤t beschreibt innerhalb dieser Arbeit
immer ein getaktetes Verhalten, bei dem alle an dem globalen Prozess beteiligten
Knoten in vorgegebenen Intervallen Operationen ausfÃ¼hren. Bei der NebenlÃ¤ufig-
keit hingegen entfÃ¤llt diese Bedingung der Taktung und zwei Operationen kÃ¶nnen
mit vollstÃ¤ndig beliebigem zeitlichen Delta zueinander erfolgen.


Formal ist das Verhalten von Petrinetzen durch verschiedene Prinzipien definiert.
Das Prinzip der DualitÃ¤t besagt wie eingangs beschrieben, dass zwei disjunkte
Mengen an Grundelementen existieren: Die Stellen, in denen Marken abgelegt
sein kÃ¶nnen, welche wiederum Daten bzw. Ressourcen modellieren kÃ¶nnen, sowie
die Transitionen, welche beim Feuern Marken aus Stellen entnehmen und in einer
einzelnen Aktion in andere Stellen hineinlegen kÃ¶nnen. Wichtig ist dabei, dass
die Marken von der Transition stets verbraucht und erzeugt werden und nicht
etwa verschoben. Auch die Anzahl der erzeugten und verbrauchten Marken einer
einzelnen Transition muss nicht identisch sein.


Das Prinzip der LokalitÃ¤t besagt, dass das Verhalten einer Transition ausschlieÃŸ-
lich durch die Gesamtheit ihrer Eingangs- und Ausgangselemente (der LokalitÃ¤t)


1Siehe auch: https://www.omg.org/spec/UML/ - Zuletzt abgerufen am 24.01.2022


bestimmt wird. Das Prinzip der NebenlÃ¤ufigkeit besagt, dass Transitionen mit
einer disjunkten LokalitÃ¤t vollstÃ¤ndig unabhÃ¤ngig voneinander schalten kÃ¶nnen.


DarÃ¼ber hinaus existieren zwei grundlegende Arten und Weisen Petrinetze darzu-
stellen: Zum einen die grafische Darstellung, bei der nach Konvention die Menge
von PlÃ¤tzen durch Kreise und die Menge von Transitionen durch Rechtecke und
die Zuordnung als Eingangs- oder Ausgangselement durch eine gerichtete Kan-
te dargestellt werden. Zum anderen eine formaltextuelle Darstellung, bei der die
Spezifikation eines Netzes mithilfe von mathematischen Konstrukten wie Mengen
angegeben wird. Dabei ist vor allem darauf zu achten, dass die beiden Darstel-
lungsformen jeweils zueinander Ã¤quivalent sind. Beide Darstellungsformen haben
ihre jeweiligen Vorteile, so sind Beweise auf der formaltextuellen Darstellungs-
form wesentlich einfacher zu fÃ¼hren, wÃ¤hrend Beispiele in grafischer Darstellung
um ein Vielfaches anschaulicher sind.


Beispiel 2.1. In Abbildung 2.1 befindet sich ein Beispiel fÃ¼r ein Petrinetz in
grafischer Darstellung. In ğ‘1 und ğ‘4 steht jeweils eine Marke zur VerfÃ¼gung,
sodass ğ‘¡1 feuern und eine Marke in ğ‘3 ablegen kann. ğ‘¡2 ist nun aktiviert und
kann schalten und ğ‘3 wieder leeren, da der Vorbereich von ğ‘¡2, welcher nur ğ‘3
umfasst, nun eine Marke beinhaltet. Nach dem Feuern legt ğ‘¡2 eine weitere Marke
in ğ‘2 ab. ğ‘¡3 kann unabhÃ¤ngig und beliebig oft zu jeder Zeit nebenlÃ¤ufig feuern.


DarÃ¼ber hinaus wird im Folgenden eine formale Definition von Netzen erfolgen.
Diese ist entnommen und Ã¼bersetzt aus (Girault und Valk, 2003, Seite 14), ist
aber fÃ¼r den Kontext der Arbeit auf endliche Netze angepasst.


Nicht endliche Netze sind fÃ¼r die Modellierung nicht endender Prozesse durchaus
Ã¼blich. Tiefergehende semantische Betrachtungen in Hinblick auf das Prozessver-
halten sind jedoch nicht Teil dieser Arbeit, sodass eine EinschrÃ¤nkung auf endliche
Netze erfolgen kann. Alle Netzmodelle, welche als explizite ReprÃ¤sentationen von
Systemen zum Einsatz kommen, sind endlich.


Definition 2.2 (Netz). Ein Netz ist ein Tripel ğ‘ = (ğ‘ƒ , ğ‘‡ , ğ¹ ),
wobei:


â€¢ ğ‘ƒ eine [endliche] Menge an PlÃ¤tzen ist.


â€¢ ğ‘‡ eine [endliche,] von ğ‘ƒ disjunkte Menge an Transitionen
ist.


â€¢ ğ¹ âŠ† (ğ‘ƒ Ã— ğ‘‡ ) âˆª (ğ‘‡ Ã— ğ‘ƒ ) eine Flussrelation fÃ¼r die Menge der
Kanten ist.


(Girault und Valk, 2003, Seite 14)


Die vereinigte Menge ğ‘ƒ âˆªğ‘‡ aller PlÃ¤tze und Transitionen in einem Netz wird auch
als Menge der Netzelemente bezeichnet. In einem Netz ğ‘ = (ğ‘ƒ , ğ‘‡ , ğ¹ ) werden fÃ¼r
ein gegebenes Netzelement ğ‘’ âˆˆ ğ‘ƒ âˆªğ‘‡ alle anderen Netzelemente ğ‘¥ âˆˆ (ğ‘ƒ âˆªğ‘‡ )\{ğ‘’},
als Vorbereich von ğ‘’ bezeichnet, falls (ğ‘¥, ğ‘’) âˆˆ ğ¹ und als Nachbereich von ğ‘’, falls
(ğ‘’, ğ‘¥) âˆˆ ğ¹ . Der Vorbereich von ğ‘’ wird mit Â»â€¢ğ‘’Â« und der Nachbereich mit Â»ğ‘’â€¢Â« be-
zeichnet. Es ist zu beachten, dass sowohl Vor- als auch Nachbereich stets gÃ¤nzlich
vom jeweils anderen Typ (Platz oder Transition) sind wie ihr Bezugselement.


In einem gegebenen Netz kann ein Teil der PlÃ¤tze markiert sein. In PlÃ¤tzen kÃ¶nnen
einzelne Marken existieren, wobei die Gesamtmenge aller Marken als Markierung
bezeichnet wird. Eine Marke wird in der graphischen ReprÃ¤sentation in einem
Platz zumeist mit einem schwarzen Punkt dargestellt. Eine Marke in einem Platz
ist notwendige (aber nicht immer hinreichende) Voraussetzung fÃ¼r das Feuern ei-
ner Transition im Nachbereich des Platzes. Eine Transition kann nur dann feuern,
wenn alle PlÃ¤tze in ihrem Vorbereich eine Marke beinhalten. Die Transition wird
in diesem Fall als aktiviert bezeichnet.


2.2.1. P/T-Netze


WÃ¤hrend klassische Petrinetze gut dafÃ¼r geeignet sind nebenlÃ¤ufige Prozesse abzu-
bilden, ist ihre AusdrucksmÃ¤chtigkeit doch eingeschrÃ¤nkt. Insbesondere bei groÃŸen
Systemen ist eine sehr groÃŸe Zahl an Stellen fÃ¼r eine korrekte Abbildung notwen-
dig. Aus diesem Grund existieren neben dem klassischen Petrinetzformalismus
noch eine Vielzahl weiterer Formalismen. Eine sehr einfache Erweiterung bilden
die sogenannten P/T Netze, welche lediglich eine Anfangsmarkierung, sowie ei-
ne Gewichtungsfunktion der Flussrelation hinzufÃ¼gen. DarÃ¼ber hinaus erlauben
P/T Netze die Anwesenheit mehrerer Marken auf einem Platz. In der graphischen
Darstellung kÃ¶nnen an Kanten ganze Zahlen aufgefÃ¼hrt sein, welche die fÃ¼r einen
Feuervorgang benÃ¶tigte Markenanzahl von dem entsprechenden Platz bzw. die
Anzahl an produzierten Marken angeben.


Abbildung 2.2.: Ein Beispiel fÃ¼r ein P/T-Netz


Analog zur Definition von Petrinetzen sollen P/T Netze im Wesentlichen nach
(Girault und Valk, 2003) wie folgt definiert werden:


Definition 2.3 (P/T-Netz). Ein P/T-Netz ğ‘ = (ğ‘ƒ , ğ‘‡ , ğ¹ , ğ‘Š , m ) ist ein 5- 0
Tupel. Dabei ist:


â€¢ (ğ‘ƒ , ğ‘‡ , ğ¹ ) ein Netz.


â€¢ ğ‘Š âˆ¶ ğ¹ â†’ â„• eine Gewichtungsfunktion. +


â€¢ m âˆ¶ ğ‘ƒ â†’ â„• eine Initialmarkierung. 0 0


Beispiel 2.4. Ein Beispiel fÃ¼r ein P/T-Netz findet sich in Abbildung 2.2. Das
Netz besteht aus drei zusammenhÃ¤ngenden Komponenten. Die Transition ğ‘¡1 be-
sitzt weder Vor- noch Nachbereich, die Transition ğ‘¡2 hingegen einen Platz in ihrem
Nachbereich. ğ‘¡3 benÃ¶tigt eine Marke aus dem Platz ğ‘1, sowie zwei Marken aus
dem Platz ğ‘4 und erzeugt beim Feuern vier Marken, welche in den Platz ğ‘2 gelegt
werden. Da sowohl ğ‘¡1 als auch ğ‘¡2 keinen Vorbereich haben, kÃ¶nnen beide beliebig
oft feuern. Obwohl in ğ‘4 insgesamt vier Marken zur VerfÃ¼gung stehen, steht in
ğ‘1 nur eine Marke zur VerfÃ¼gung, sodass ğ‘¡3 nur ein einziges Mal schalten kann.
Folglich kann ğ‘¡4 insgesamt vier mal schalten, jedoch erst nachdem ğ‘¡3 geschaltet
hat.


2.2.2. Erreichbarkeitsgraphen


FÃ¼r die Beantwortung einzelner Fragestellungen im Kontext eines Netzes ist es
hilfreich einen systematischen Verlauf aller mÃ¶glichen Schaltungen durch das Netz
abbilden zu kÃ¶nnen. Dies wird durch die Konstruktion eines Erreichbarkeitsgra-
phen umgesetzt. In einfachen (Ã¼blichen) Erreichbarkeitsgraphen kann das Schalt-
verhalten eines Netz nach Interleaving-Semantik (sequentielles Schalten) abgele-
sen werden. Genauere Beschreibungen zur Interleaving- und anderen Petrinetzse-
mantiken folgen in Abschnitt 2.2.5.


Abbildung 2.3.: Ein Beispiel fÃ¼r ein gefÃ¤rbtes Netz


Dabei wird ausgehend von der Initialmarkierung sequenziell jede mÃ¶gliche Schal-
tung einer aktivierten Transition betrachtet. Die jeweiligen Folgemarkierungen
werden in den Graphen aufgenommen, dessen erster Knoten der Initialmarkie-
rung entspricht. Gleiche Markierungen sind unabhÃ¤ngig von ihrer Entstehung
auch dieselben Knoten im Erreichbarkeitsgraphen. Auf diese Weise werden syste-
matisch alle erreichbaren ZustÃ¤nde des Systems gefunden. Erreichbarkeitsgraphen
sind nur endlich, sofern das zugehÃ¶rige Netz beschrÃ¤nkt ist. Ohne eine genaue
Definition anzugeben, bedeutet BeschrÃ¤nktheit, dass kein Platz im Netz durch
wiederholte SchaltvorgÃ¤nge beliebig viele Marken aufnehmen kann. Ferner sind
Erreichbarkeitsgraphen im schlimmsten Fall hyperexponentiell groÃŸ bzw. nicht
primitiv-rekursiv in Hinblick auf die GrÃ¶ÃŸe des gesamten Netzes.


2.2.3. GefÃ¤rbte Netze


Eine Erweiterung der P/T-Netze ergibt sich, indem fÃ¼r bestimmte Bedeutungen
verschiedene Marken verwendet werden. Die Bezeichnung Â»FarbeÂ« ist fÃ¼r die Ty-
pen der Marken gebrÃ¤uchlich, daher die Bezeichnung gefÃ¤rbtes Netz.


Es liegt nahe, Transitionen die MÃ¶glichkeit einzurÃ¤umen zwischen Marken zu un-
terscheiden. Zu diesem Zwecke kÃ¶nnen mit sogenannten Transitions-Guards Be-
dingungen (PrÃ¤dikate) hinzugefÃ¼gt werden, welche der Marken zum Schalten ver-
wendet werden dÃ¼rfen und welcher Typ Marken produziert wird. An den Kanten
werden in diesen FÃ¤llen Variablen eingesetzt, welche durch die Guard-PrÃ¤dikate
referenziert werden. Im Gegensatz zu den einfachen P/T-Netzen sind gefÃ¤rbte
Netze bereits Turing-mÃ¤chtig (sofern sie beliebige Farbmengen aufweisen).


Beispiel 2.5. In Abbildung 2.3 findet sich ein Beispiel fÃ¼r ein gefÃ¤rbtes Netz.
Im Platz ğ‘1 befinden sich je eine Marke des Markentyps Â»5Â« und Â»6Â«, sowie
eine des Typs Â»3Â« in ğ‘3. Die Transition ğ‘¡1 kann beliebig schalten, wÃ¤hrend die
Transition ğ‘¡2 durch ein Guard-PrÃ¤dikat eingeschrÃ¤nkt ist. Die Transition ğ‘¡2 kann
nur mit solchen Marken schalten, bei denen der Typ (als Ganzzahl betrachtet)
der Marke aus ğ‘3 ein Teiler der Marke aus ğ‘1 ist. Folglich kÃ¶nnen hier zwei finale


Markierungen erreicht werden: Entweder liegen zwei Marken des Typs der Marken
aus ğ‘1 in ğ‘2, wenn ğ‘¡1 zwei mal geschaltet hat, oder aber eine Marke Â»5Â« liegt in
ğ‘2 und eine Marke Â»6Â« in ğ‘4. Dies ist der Fall, wenn ğ‘¡1 einmal mit ğ‘¥ = 5 und ğ‘¡2
ebenfalls einmal geschaltet hat. Es gibt jedoch keine MÃ¶glichkeit eine Marke vom
Typ Â»5Â« in den Platz ğ‘4 abzulegen, da dies durch das Guard-PrÃ¤dikat verhindert
wird.


2.2.4. Netze-in-Netzen


Eine weitere MÃ¶glichkeit Netze zu erweitern besteht darin, das Konzept von Net-
zen-in-Netzen (Valk, 1998) zuzulassen. Dabei kann eine Marke ein ganzes eigen-
stÃ¤ndiges (Sub-) Netz darstellen, welches durch das Ã¼bergeordnete Netz bewegt
werden kann. MaÃŸgebliches Leitbild dabei war die Idee mobiler Agenten, welche
sich durch eine Plattform bewegen und an unterschiedlichen Orten unterschiedli-
che Operationen ausfÃ¼hren kÃ¶nnen. Die Agenten Ã¤ndern intern dabei jedoch nicht
ihre Verhaltensstruktur, sondern lediglich ggf. ihren gegenwÃ¤rtigen Zustand. Net-
ze-in-Netzen bzw. Objektnetze verfolgen zusÃ¤tzlich AnsÃ¤tze der objektorientierten
Programmierung, da Marken einen Verweis auf ein anderes Netz darstellen, ge-
nau wie in der objektorientierten Programmierung Objekte Referenzen auf andere
Objekte halten kÃ¶nnen.


Eine Erweiterung auf Basis der Netze-in-Netzen findet sich in Form des Referenz-
netzformalismus. Da dieser eine zentrale Vorarbeit dieser Arbeit ist, wurde ihm
der eigenstÃ¤ndige Abschnitt 2.3 gewidmet.


2.2.5. Petrinetzsemantiken


Bei der Simulation bzw. AusfÃ¼hrung von Petrinetz-Modellen existieren verschiede-
ne Semantiken. Als einfachste Semantik kann die Schaltsequenz-Semantik genannt
werden, bei der zu einem Zeitpunkt nur eine Transition feuert und alle produzier-
ten und konsumierten Marken zum Zeitpunkt des nÃ¤chsten Transitionsfeuerns
eindeutig feststehen. Durch diese Semantik kann selbstverstÃ¤ndlich keine echte
NebenlÃ¤ufigkeit erzeugt werden, da alle Transitionen in einer zeitlichen Abfolge
gefeuert werden. Die Garantien an das Vorhandensein von Marken und den Ge-
samtzustand sind hierbei jedoch am hÃ¶chsten. Die Schaltsequenz-Semantik wird
auch als Interleaving-Semantik bezeichnet.


Werden innerhalb eines Zeitpunktes nicht nur eine einzige Transition, sondern
gleich mehrere Transitionen auf einmal geschaltet, so wird das Netz mittels Schritt-
Semantik bzw. Step-Semantik simuliert. Diese Semantik ermÃ¶glicht eine gewisse
Form von NebenlÃ¤ufigkeit, basiert aber durch die Existenz von Takten (Schrit-
ten) auf ParallelitÃ¤t. Dies bedeutet, dass das Netz immer nach einem Schritt und


vor dem nÃ¤chsten Schritt in einen konsistenten Zustand Ã¼berfÃ¼hrt wird. Die Aus-
fÃ¼hrung unterschiedlich komplexer Operation ist jedoch nur schwer abbildbar, da
Zeitschritte diskret betrachtet werden. Im Zweifel fÃ¼hrt die ParallelitÃ¤t zu lÃ¤nge-
ren Wartezeiten bei kÃ¼rzeren Operationen.


Die letzte betrachtete Semantik ist die sogenannte True-Concurrency-Semantik
(dt. Â»echte NebenlÃ¤ufigkeitÂ«). Sie wird auch als Partial-Order-Semantik (dt. Â»Se-
mantik partieller OrdnungÂ«) oder auch als TC-Semantik bezeichnet. Hierbei sind
Markierungen von PlÃ¤tzen und Transitionsschaltungen lediglich durch eine par-
tielle Ordnung in Relation zueinander gesetzt. Dies hat zur Folge, dass manche
Schaltungen in ihrer zeitlichen Reihenfolge unvergleichbar sind. Diese Semantik
hat daher die stÃ¤rkste Anlehnung an ein natÃ¼rliches System aus interagierenden
Agenten, wie sie auch in der realen Welt anzutreffen sind. Als Nachteil kann aufge-
fÃ¼hrt werden, dass Netzsimulationen nach der True-Concurrency-Semantik nicht
zwangslÃ¤ufig zu einem bestimmten Zeitpunkt einen Zustand aufweisen mÃ¼ssen,
bei dem keine Transition aktiv feuert. Diese Eigenschaft wird spÃ¤ter noch ein-
mal adressiert und trÃ¤gt erheblich zur KomplexitÃ¤t der Ãœberlegungen bei. Wird
jedoch der Gesamtablauf einer Schaltung als Kausalnetz (ein Netz ohne Nichtde-
terminismus) dargestellt, lassen sich durch Schnitte durch den Graphen, welche
ausschlieÃŸlich durch PlÃ¤tze verlaufen (sogenannte P-Schnitte), mÃ¶gliche ZustÃ¤nde
des Systems beschreiben. Diese Ãœberlegung wird im Kontext von True-Concur-
rency Checkpoints in Abschnitt 11.6.6 erneut aufgegriffen werden.


FÃ¼r den verbleibenden Teil der Arbeit wird bei der Simulation von Petrinetzen je-
der Form stets der Einsatz von True-Concurrency-Semantik angenommen, sofern
dies nicht explizit abweichend angegeben ist. Ausnahmen sind mit der Referenz
auf die entsprechend verwendete Semantik kenntlich gemacht.


2.2.6. Weitere relevante Konzepte im Kontext von Petrinetzen


AbschlieÃŸend werden in diesem Abschnitt noch einige weitere Konzepte vorge-
stellt, welche an einzelnen Stellen innerhalb der Arbeit referenziert werden. Diese
haben dabei entweder keine herausragende Stellung oder werden an der betref-
fenden Stelle noch einmal detaillierter eingefÃ¼hrt.


Invarianten


Invarianten beschreiben bestimmte strukturelle Eigenschaften von Netzen. So
kann beispielsweise die (gewichtete) Menge aller Marken in einer bestimmten Teil-
menge aller PlÃ¤tze unabhÃ¤ngig von erfolgten FeuervorgÃ¤ngen konstant sein oder
eine bestimmte Folge von TransitionsfeuervorgÃ¤ngen die Markierung eines Netzes
wieder in den gleichen Zustand versetzen wie vor der Folge von FeuervorgÃ¤ngen.


Im Allgemeinen wird zwischen Platz- und Transitionsinvarianten unterschieden.
Da beide Formen im Kontext der Arbeit nur am Rande erwÃ¤hnt werden, soll an
dieser Stelle die intuitive EinfÃ¼hrung genÃ¼gen und auf eine volle formale Definition
verzichtet werden.


KomplementÃ¤re PlÃ¤tze


KomplementÃ¤re PlÃ¤tze beschreiben ebenfalls eine strukturelle Eigenschaft von
Netzelementen. FÃ¼r bestimmte AnwendungsfÃ¤lle kann es hilfreich sein, ein stati-
sches Limit fÃ¼r die Marken in einem Platz einzufÃ¼hren. Ein Anwendungsbeispiel
kÃ¶nnte die maximale Anzahl an verfÃ¼gbaren ArbeitsplÃ¤tzen umfassen. Strukturell
kann dies so modelliert werden, dass neben dem Platz, welcher die ArbeitsplÃ¤t-
ze beschreibt, ein weiterer Platz mit der maximal zulÃ¤ssigen Anzahl an Marken
existiert. Dieser Platz besitzt die umgekehrte Flussrelation des Platzes, welche die
ArbeitsplÃ¤tze beschreibt. Legt nun eine Transition eine Marke in den Platz, zieht
sie gleichzeitig eine Marke vom komplementÃ¤ren Platz ab. Transitionen, welche
Marken vom Platz entfernen, legen gleichzeitig Marken im komplementÃ¤ren Platz
ab. KomplementÃ¤re PlÃ¤tze sind ein effektives Mittel, um PlÃ¤tze zu beschrÃ¤nken,
ohne dass die AusdrucksmÃ¤chtigkeit von Netzen eingeschrÃ¤nkt wird.


Verklemmung


Die Verklemmung ist eine dynamische Eigenschaft der Simulation eines Petrinet-
zes. Sie beschreibt den Zustand, in dem keine Transition des Netzes aktiviert ist
und somit auch keine Transition feuern kann. Die Bedeutung fÃ¼r das simulier-
te System ist dabei nicht vorweggenommen. Ein verklemmtes Netz kann ebenso
einen Fehlerzustand darstellen wie auch eine erfolgreich abgeschlossene Bearbei-
tung seiner Aufgaben. Durch eine Verklemmung terminiert die Simulation eines
Netzes.


Workflownetze


Workflownetze sind eine spezielle Kategorie von Petrinetzen. Sie kÃ¶nnen ein-
gesetzt werden, um GeschÃ¤ftsprozesse zu modellieren. Sie werden im Kontext
der Agentenkommunikation erneut aufgegriffen werden. Workflownetze definie-
ren sich nach (Aalst, 1997) (Ã¼bersetzt) wie folgt:


Definition 2.6 (Workflow Netz). Ein Netz ğ‘ = (ğ‘ƒ , ğ‘‡ , ğ¹ ) ist
ein Workflow Netz, genau dann wenn:


â€¢ ğ‘ zwei spezielle PlÃ¤tze ğ‘– und ğ‘œ besitzt. ğ‘– ist eine Quelle:
â€¢ğ‘– = âˆ… und ğ‘œ eine Senke: ğ‘œâ€¢ = âˆ….


â€¢ Falls eine Transition ğ‘¡âˆ— zu ğ‘ hinzugefÃ¼gt wird, welche die
PlÃ¤tze ğ‘œ und ğ‘– verbindet (â€¢ğ‘¡âˆ— = {ğ‘œ} und ğ‘¡âˆ—â€¢ = {ğ‘–}), dann
ist das resultierende Netz streng zusammenhÃ¤ngend.


â€” (Aalst, 1997, Seite 413)


DarÃ¼ber hinaus kann ein Workflownetz als korrekt bezeichnet werden, falls:


Definition 2.7 (Korrektes Workflow Netz). Eine Prozedur, wel-
che durch ein Workflow Netz ğ‘ = (ğ‘ƒ , ğ‘‡ , ğ¹ ) modelliert wird, ist
genau dann korrekt, wenn:


â€¢ FÃ¼r jeden Zustand ğ‘€, welcher von Zustand ğ‘– erreicht werden
kann, eine Feuersequenz existiert, welche von ğ‘€ zu ğ‘œ fÃ¼hrt. âˆ— âˆ—
Formal: âˆ€ğ‘€(ğ‘– â†’ ğ‘€) â‡’ (ğ‘€ â†’ ğ‘œ)


â€¢ Zustand ğ‘œ ist der einzig erreichbare Zustand aus Zustand ğ‘–
mit wenigstens einer Marke im Platz ğ‘œ. âˆ—
Formal: âˆ€ğ‘€(ğ‘– â†’ ğ‘€ âˆ§ ğ‘€ â‰¥ ğ‘œ) â‡’ (ğ‘€ = ğ‘œ)


â€¢ Es existieren keine nicht lebendigen Transitionen in (ğ‘, ğ‘–).
âˆ— ğ‘¡
Formal: âˆ€ âˆƒ ğ‘– â†’ ğ‘€ â†’ ğ‘€â€² ğ‘¡âˆˆğ‘‡ ğ‘€,ğ‘€â€²


â€” (Aalst, 1997, Seite 413-414)


Ein weiteres Konzept von Interesse im Kontext der Workflownetze ist die Task-
Transition (Aalst, 1997; Jacob, 2002), welche den Fehlschlag des Feuervorgangs
unterstÃ¼tzt und im Falle des Fehlschlags alle Marken zurÃ¼ck in die jeweiligen
PlÃ¤tze des Vorbereichs legt. Die Task-Transition wird detaillierter in Abschnitt 5.1
vorgestellt.


2.3. Referenznetze


Ausgehend von der Â»Netze-in-NetzenÂ« Theorie (Valk, 1998), Â»Objektorientier-
ten NetzenÂ« (Moldt, 1996) sowie Â»Synchronen KanÃ¤lenÂ« (S. Christensen und
Hansen, 1994; Maier und Moldt, 2001), welche im folgenden Abschnitt 2.3.2
noch erlÃ¤utert werden, liegt die Grundidee bei Referenznetzen darin diese Kon-
zepte zu vereinen. Die Theorie zu den Referenznetzen und der zugehÃ¶rige Refe-
renznetzformalismus geht im Wesentlichen auf die Arbeiten von Olaf Kummer


(Kummer, 1996, 1998, 1999, 2000, 2002) zurÃ¼ck, nach welchen sich auch die
AusfÃ¼hrung an dieser Stelle richtet.


Referenznetze verbinden analog zu Netzen-in-Netzen die Konzepte der objektori-
entierten Programmierung von Klassen und Instanzen mit der Petrinetztheorie.
Somit existieren im Referenznetzformalismus nicht nur Netze mit PlÃ¤tzen und
Transitionen, sondern auch Netzinstanzen mit Platzinstanzen und Transitionsin-
stanzen. Diese Eigenschaft ist fundamental fÃ¼r die Grundlage dieser Arbeit, da
durch diese Eigenschaft von Referenznetzen zur Simulationszeit weitere Instan-
zen von Netzen generiert werden kÃ¶nnen. Die physikalische GrÃ¶ÃŸe der Simula-
tion (verbrauchter Speicher, benÃ¶tigte Prozessorressourcen, etc.) sind also nicht
zwangslÃ¤ufig im Vorhinein bekannt. Die Netzstruktur ist dynamisch, sodass Re-
ferenznetze eine inhÃ¤rent hÃ¶here KomplexitÃ¤t aufweisen als niedrigere Petrinetz-
formalismen.


2.3.1. Instanziierung


Wie eingehend beschrieben, ist eine der wichtigsten Eigenschaften des Referenz-
netzformalismus die Instanziierung von Netzen. WÃ¤hrend in klassischen Petrinetz-
Formalismen direkt in einem Netz simuliert wurde, betrachtet der Referenznetz-
formalismus ein Netz wie eine Klasse der objektorientierten Programmierung.
Auf Basis dieses Netzes kÃ¶nnen zur Laufzeit beliebig viele Netzinstanzen erzeugt
werden. Dies bedeutet insbesondere auch, dass durch Netzinstanzen sowohl PlÃ¤t-
ze als auch Transitionen eines Netzes insgesamt in beliebig hÃ¤ufiger Replikation
existieren kÃ¶nnen. Somit liegt es nahe, neben Netzinstanzen auch von Platz- und
Transitionsinstanzen zu sprechen. Um zusÃ¤tzlich den Unterschied zwischen Net-
zen und Netzinstanzen zu betonen, werden Netze im Rahmen der Arbeit auch als
statische Netze oder Netztemplates bezeichnet. Insbesondere wird in dieser Arbeit
durchweg im Kontext von Referenznetzen durch Â»NetzÂ« stets das Netztemplate
bzw. statische Netz und durch Â»NetzinstanzÂ« die Instanz eines Netzes bezeichnet.


Damit das Konzept der Instanziierung von Netzen einen gewinnbringenden Nut-
zen aufweist, ist es notwendig innerhalb der Netzinstanzen mit anderen Netz-
instanzen umgehen zu kÃ¶nnen. An dieser Stelle hilft das Konzept von Netzen-
in-Netzen (Valk, 1998), bei dem ungerichtete synchrone KanÃ¤le zum Einsatz
kommen, sodass das Schalten von Transitionen synchronisiert wird und bei dem
einzelne Netze als Marken innerhalb von PlÃ¤tzen in anderen Netzen existieren
kÃ¶nnen. Im Formalismus der Referenznetze ist dieser Ansatz ebenfalls umgesetzt,
jedoch mit Hilfe von Referenzen auf die anderen Netzinstanzen. So begrÃ¼ndet sich
auch der Name Referenznetze.


Innerhalb von Netzinstanzen von Referenznetzen besteht somit die MÃ¶glichkeit
neue Netzinstanzen von anderen bekannten statischen Netzen zu erzeugen. Da die


Erzeugung einer neuen Netzinstanz stets eine Aktion ist, liegt es nahe, dass sie
mittels einer speziellen Anschrift an einer Transition umgesetzt ist. Feuert eine
derartige Transition innerhalb einer Netzinstanz, so entsteht eine Marke mit einer
Referenz auf eine neu erzeugte Netzinstanz.


2.3.2. Synchrone KanÃ¤le


Das bloÃŸe Erzeugen von Netzinstanzen, welche unabhÃ¤ngig voneinander schalten
kÃ¶nnen und lediglich Referenzen zu jeweils anderen Netzinstanzen halten, bietet
auf den ersten Blick keine groÃŸen Vorteile. An dieser Stelle fehlt eine Methodik
um zwischen den jeweiligen Netzinstanzen zu kommunizieren. Referenznetze rea-
lisieren dieses BedÃ¼rfnis nach Kommunikation mithilfe sogenannter synchroner
KanÃ¤le.


Der Austausch von Nachrichten ist bei jeder Form der Programmierung und der
Modellierung von AblÃ¤ufen, Prozessen und Protokollen einer der zentralen Be-
standteile. WÃ¤hrend in der klassischen Programmierung meist ein Aufrufer und
ein Aufgerufener existieren, ist dieses Modell gerade fÃ¼r die Abbildung natÃ¼rlicher
Kommunikationsstrukturen nicht immer zutreffend. Die Annahme eines Kom-
munikationsinitiators, auf dessen Initiierung ein gleichberechtigter Informations-
austausch folgt ist im Allgemeinen realistischer. Synchrone KanÃ¤le beabsichtigen
diesen Zusammenhang in Form einer Gruppensynchronisation zu formalisieren.


Wie alle Inhalte dieser Arbeit zu Referenznetzen orientiert sich auch dieser Ab-
schnitt im Wesentlichen an der Dissertation (Kummer, 2002). Synchrone KanÃ¤le
in diesem Kontext als Vorarbeit schafft die VerÃ¶ffentlichung (S. Christensen
und Hansen, 1994).


Um die Abbildung von Gruppensynchronisation auf Petrinetze umsetzen zu kÃ¶n-
nen, ist es zunÃ¤chst notwendig zu betrachten, welche Aspekte bereits von her-
kÃ¶mmlichen Petrinetzen, wie P/T-Netzen, umgesetzt werden. So bieten Petri-
netze beispielsweise die MÃ¶glichkeit individuelles Verhalten der einzelnen Kom-
munikationspartner durch die inhÃ¤rente NebenlÃ¤ufigkeit abzubilden. Dabei spielt
die Betrachtung der im Falle der Simulation anzuwendenden Petrinetzsemantik
eine entscheidende Rolle. Die True-Concurrency-Semantik bildet wie im vorhe-
rigen Abschnitt beschrieben die natÃ¼rliche Kommunikation am ehesten ab und
soll daher betrachtet werden. Da durch die NebenlÃ¤ufigkeit auch Transitionen zu
sich selbst nebenlÃ¤ufig schalten kÃ¶nnen und das Unterbinden der MÃ¶glichkeit zum
Schalten ausschlieÃŸlich durch fehlende Marken erzeugt werden kann, findet sich
klassisch keine MÃ¶glichkeit mehrere Transitionen exakt gleichzeitig zu schalten
und dabei Informationen zwischen den Transitionen auszutauschen. Der Forma-
lismus muss somit um eine Mechanik erweitert werden, welche dieses Verhalten
unterstÃ¼tzt. Dies kann beispielsweise durch Transitionsanschriften formalisiert


werden, wie es bei Referenznetzen der Fall ist. Diese benÃ¶tigen eine Informati-
on darÃ¼ber welche Transitionen an der Synchronisation teilnehmen und welche
Art von Informationen ausgetauscht werden kann. WÃ¤hrend die erste Komponen-
te durch eine gezielte Benennung des entsprechenden Kanals gewÃ¤hrleistet werden
kann, mÃ¼ssen fÃ¼r den zweiten Aspekt Parameter eingesetzt werden.


WÃ¤hrend die EinfÃ¼hrung von synchronen KanÃ¤len in den Petrinetzformalismus
auf den ersten Blick konzeptuell nicht komplex erscheint, ergeben sich bei ge-
nauerer Betrachtung jedoch diverse Schwierigkeiten in der detaillierten Umset-
zung. Petrinetze erlauben im normalen Fall umfangreiche Zusammenlegungen und
Spaltungen bestimmter KontrollflÃ¼sse, insbesondere durch den Einsatz gefÃ¤rbter
Netze. Der Fachbegriff hierzu lautet (Ent-)Faltung. Ein Netz mit synchronen Ka-
nÃ¤len kann jedoch bei extrem komplexen Beziehungen zwischen den Synchronisa-
tionspartnern in eine Situation laufen, bei der ein endliches Netz mit synchronen
KanÃ¤len nicht mehr endlich in seiner entpackten Fassung ist. (S. Christensen
und Hansen, 1994) beschreiben in diesem Kontext jedoch hinreichende Bedin-
gungen, die ein Netz mit synchronen KanÃ¤len erfÃ¼llen muss, damit es zu solchen
Problemen nicht kommt.


2.3.3. Anschriften


Der Referenznetzformalismus zÃ¤hlt zu den hÃ¶heren$$$2$$$ Petrinetz-Formalismen. Es ist
daher naheliegend, dass dafÃ¼r eine komplexe Anschriftensprache notwendig ist.
Die formale Definition von Referenznetzen im Originalwerk (Kummer, 2002) ist
absichtlich allgemein gehalten und auf Basis von Graphersetzungssystemen spezi-
fiziert. In der grundlegenden Definition kommen beschriftete Algebren zum Ein-
satz und auf eine Ausformulierung von etwaigen Beschriftungen wird im formalen
Teil der Arbeit zunÃ¤chst vollstÃ¤ndig verzichtet. Jedoch ist es fÃ¼r den Einsatz in
dieser Arbeit hilfreich den Referenznetzformalismus im Kontext der Implemen-
tation im Simulator Renew und der Programmiersprache Java zu betrachten
und an der zugehÃ¶rigen Stelle direkt Anschriften zu behandeln. Folglich wird die-
ser Abschnitt zur Anschriftensprache, auch wenn er formal zu der Definition von
Referenznetzen zÃ¤hlt, in Abschnitt 2.8 zum Simulator Renew behandelt.


2.3.4. Beispiele zu Referenznetzen


Die anschauliche Betrachtung von beispielhaften Referenznetzen bedarf der Kon-
kretisierung der Anschriftensprache. Wie im Abschnitt 2.3.3 erlÃ¤utert, umfasst
die Konkretisierung der abstrakten Referenznetze im Rahmen dieser Arbeit die


2Zum Begriff der Â»hÃ¶herenÂ« Petrinetz-Formalismen siehe beispielsweise (Jensen und Rozen-
berg, 1991) und (Jensen, 2001)


Anwendung auf die Programmiersprache Java. Aus diesem Grund wird auf die
Darstellung eines Beispiels von Referenznetzen nur auf Basis des Formalismus
verzichtet und dieses nur im Kontext der Realisierung mit Java betrachtet. Bei-
spiele finden sich somit im Unterabschnitt 2.8.3 zu Renew, nachdem die Details
der Implementation in Renew behandelt wurden.


2.4. Softwareagenten


Softwareagenten sind seit langer Zeit ein aktives Forschungs- und Anwendungs-
feld. Die zentrale Idee umfasst die Kapselung einzelner Bereiche der Software
in Komponenten, welche eine gewisse Autonomie aufweisen. Diese Komponenten
werden als Agenten bezeichnet. Agenten besitzen eine Wissensbasis und kommu-
nizieren Ã¼ber Nachrichten. Die Antwort auf eine Nachricht ist dabei nicht explizit
ausgestaltet oder fÃ¼r den Agenten verpflichtend, wodurch sich Agenten elementar
von beispielsweise Subroutinen oder Objekten unterscheiden. Agenten versuchen
das Verhalten von Menschen und anderen autonomen RealweltentitÃ¤ten unter-
einander genauer abzubilden als es durch andere Softwareentwicklungsmuster der
Fall ist.


Dieser Abschnitt gibt eine Definition eines Softwareagenten fÃ¼r den Rahmen der
Arbeit an, fÃ¼hrt die grundlegenden Ãœberlegungen der Organisation Â»Foundation
for Intelligent Physical AgentsÂ« (FIPA) an und beschreibt den Paose Ansatz.


2.4.1. Definitionen eines Agenten


In der Literatur finden sich sehr verschiedene Definitionen des Agentenbegriffs.
So definiert beispielsweise Shoham:


[...] An entity that functions continuously and autonomously in
an environment in which other processes take place and other
agents exist.
(dt.: Eine EntitÃ¤t, welche fortlaufend und autonom in einer Um-
gebung funktioniert, in der andere Prozesse ablaufen und andere
Agenten existieren.)
â€” (Shoham, 1993, Seite 52)


Ã„hnlich definiert die FIPA, deren Vorgaben detaillierter in Abschnitt 2.4.2 auf-
gegriffen werden:


An agent is a computational process that implements the auto-
nomous, communicating functionality of an application.
(dt.: Ein Agent ist ein Berechnungsprozess, welcher die autono-
me und kommunizierende FunktionalitÃ¤t einer Anwendung imple-
mentiert.)


â€” (Foundation for Intelligent Physical Agents
(FIPA), 2002, Zeile 1019, Seite 29)


Eine sehr bekannte Definition erfolgt durch Wooldridge, welche auch als Basis
in (Wagner, 2018) eingesetzt wird:


An agent is a computer system that is situated in some environ-
ment, and that is capable of autonomous action in this environ-
ment in order to meet its delegated objectives.
(dt.: Ein Agent ist ein Computersystem, welches sich ein einer
Umgebung befindet und welches in der Lage ist, autonome Ak-
tionen in dieser Umgebung auszufÃ¼hren, um seine Ã¼bertragenen
Aufgaben zu erfÃ¼llen.)


â€” (Wooldridge, 2009, Seite 21)


Auf der Basis dieser Definitionen soll nun eine entsprechende eigene Definition fÃ¼r
diese Arbeit geschaffen werden, welche zusÃ¤tzlich den fÃ¼r diese Arbeit relevanten
Begriff der Plattform umfasst:


Definition 2.8 (Agent, Plattform). Ein Agent ist ein autonomes Computersys-
tem, welches sich in einer Umgebung befindet und in der Lage ist auf bestimmen
Plattformen mit anderen Agenten in Kommunikation sowie mit den Umgebungen
bzw. Plattformen in Interaktion zu treten. Agenten nutzen diese Eigenschaften,
um ihre designierten Aufgaben zu verfolgen und zu erfÃ¼llen. Eine Plattform kann
Agenten beherbergen und mit ihnen und den Umgebungen in Interaktion treten.


Die internen AblÃ¤ufe eines Agenten umfassen verschiedene Prozesse und Opera-
tionen:


Definition 2.9 (Protokoll). Die internen AblÃ¤ufe eines Agenten werden als Pro-
tokolle bezeichnet.


Protokolle kÃ¶nnen von Agenten gestartet und beendet werden. Protokolle sind
ebenfalls in der Lage auf die Wissensbasis des Agenten zuzugreifen. Dabei liegt
ein Protokoll stets in einem Agenten, sodass ein anderer Agent keinen Zugriff auf
das Protokoll eines gleichberechtigten anderen Agenten hat. Das Protokoll kann
jedoch den Agenten veranlassen eine Nachricht zu verschicken, um so mit anderen
Agenten zu kommunizieren. Protokolle sind daher in der Arbeit anders definiert


als beispielsweise in der Netzwerkkommunikation. Als Abgrenzung werden derar-
tige Netzwerk-Protokolle verschiedener Ebenen wie beispielsweise TCP, HTTP,
FTP, usw. im Rahmen dieser Arbeit als Kommunikationsprotokolle bezeichnet.


Bei wiederverwendbaren Protokollfragmenten kÃ¶nnen Subprotokolle zum Einsatz
kommen:


Definition 2.10 (Subprotokoll). Ein Subprotokoll ist ein eigenstÃ¤ndiger Ablauf
innerhalb eines Agenten, welcher nur durch ein Ã¼bergeordnetes Protokoll gestartet
werden kann, jedoch nicht direkt durch den Agenten.


Wegen der Nachrichtenbasiertheit der Kommunikation kÃ¶nnen eingehende Nach-
richten den Start eines Protokolls verursachen. Diese Form des Protokollstarts
wird als reaktiv bezeichnet. Die gegenteilige Form tritt auf, falls der Agent das
Protokoll ohne Ã¤uÃŸeres Einwirken startet, beispielsweise durch ein anderes Pro-
tokoll. In diesem Fall wird von einem proaktiven Start des Protokolls gesprochen.


In der Kombination von Umgebung und der Gesamtheit der Agenten ergibt sich
ein Multiagentensystem.


Definition 2.11 (Multiagentensystem). Die Gesamtheit aus Agenten, Umgebun-
gen und etwaigen Plattformen wird als Multiagentensystem bezeichnet.


WÃ¤hrend Multiagentensysteme in ihrem konzeptuellen Aufbau als verteiltes Sys-
tem zu verstehen sind, muss eine Simulation eines Multiagentensystem nicht
zwangslÃ¤ufig verteilt sein, Ã¤hnlich wie auch andere verteilte Systeme auch ohne
Verteilungsaspekt simuliert werden kÃ¶nnen.


2.4.2. FIPA


Die Â»Foundation for Intelligent Physical AgentsÂ« (FIPA)3 ist eine Standardisie-
rungsorganisation des Institue of Electrical and Electronics Engineers (IEEE). Sie
wurde 1996 in der Schweiz gegrÃ¼ndet und befasst sich mit der Standardisierung
von Agenten- und Multiagentensystemen. Im Laufe ihrer Arbeit hat die FIPA
diverse Standards zu dem Thema hervorgebracht, welche weitreichende Adaption
im Bereich der agentenorientierten Softwareentwicklung erfahren haben.


Die wesentliche Architektur nach der FIPA findet sich in Abbildung 2.4. Die ein-
zelnen Bestandteile umfassen nach (Foundation for Intelligent Physical
Agents (FIPA), 2004):


Agent Management System (AMS) Bezeichnet einen Verwaltungsdienst, wel-
cher wie ein herkÃ¶mmlicher Agent ansprechbar sein muss.


3http://www.fipa.org/ - Zuletzt abgerufen am 15.12.2021


Abbildung 2.4.: Das Â»Agent Management Reference ModelÂ«. Entnommen aus
(Foundation for Intelligent Physical Agents (FIPA),
2004, Seite 5).


Directory Facilitator (DF) Bezeichnet einen Verzeichnisdienst.


Message Transport Service (MTS) Bezeichnet einen Transportservice fÃ¼r Nach-
richten, dessen interne Schnittstelle beliebig aufgebaut sein kann.


Agent Communication Channel (ACC) Bezeichnet die externe Schnittstelle des
MTS, die einheitlich ist.


Agent Message Transport Protocol (MTP) Bezeichnet die Protokolle, die von
der FIPA als Protokolle zum Nachrichtenaustausch zwischen Agenten vor-
gesehen sind.


Agent Communication Language (ACL) Bezeichnet die Sprache, die innerhalb
des MTP eingesetzt wird. Sie folgt der Sprechakttheorie von (Searle,
1969). Die Grundbausteine der ACL sind Sprechakte im Sinne der Sprech-
akttheorie.


Â»SoftwareÂ« in der Abbildung beschreibt alle Anteile der lokalen Anwendung, wel-
che nicht agentenbasiert sind.


Des Weiteren definiert die FIPA AblÃ¤ufe fÃ¼r den Agenten-Lebenszyklus in (Foun-
dation for Intelligent Physical Agents (FIPA), 2004). Ein Agent kann
initialisiert bzw. erzeugt werden und ist sodann aktiv. Anstatt aktiv zu sein, kann


er warten, pausiert sein oder umziehen. Sind die jeweiligen VorgÃ¤nge abgeschlos-
sen kehrt er in den aktiven Zustand zurÃ¼ck. Wird der Agent beendet, kehrt er
in einen Â»unbekanntenÂ« Zustand zurÃ¼ck, bis er erneut erzeugt bzw. initialisiert
wird.


2.4.3. PAOSE


Der Ansatz des Petri net-based, Agent- and Organization-Oriented
Software Engineering(Paose) (Moldt, 2005) (Cabac, DÃ¶rges, Duvi-
gneau, Moldt u. a., 2008) (Cabac, 2010) erweitert das Design und die Entwick-
lung eines Multiagentensystems zu einem Leitbild des gesamten Entwicklungspro-
zesses (Cabac, 2007). Der Ansatz wurde seit den 1990er-Jahren entwickelt und
trug im Laufe der Zeit verschiedene Namen. Anfang der 2000er-Jahre etablierte
sich das Akronym Paose (Moldt, 2005). Der Prozess ist in der Beschreibung
der Quellen eng mit der Capa-Plattform im Kontext der Mulan-Architektur
verknÃ¼pft, welche erst in Abschnitt 3.3.1 vorgestellt werden wird. Paose ist auf
konzeptueller Ebene jedoch allgemein gehalten und der Ansatz ist ohne den kon-
kreten Zusammenhang zu Capa nutzbar. Einen guten Einstieg in die Thematik
liefert auch (Wagner, 2018, Seiten 26-30).


Der Grundgedanke von Paose umfasst die Interpretation eines Entwicklerteams
als Multiagentensystem, bei dem einzelne Entwickler als Agenten verstanden wer-
den. Paose setzt damit auf der gleichen AusgangsÃ¼berlegung wie das Gesetz von
Conway (Conway, 1968) auf. Dieses besagt, dass die Struktur einer Software
der Struktur der Organisation entspricht, welche sie entwickelt. Der Einsatz des
umgekehrten Gesetzes von Conway beinhaltet die Organisation derart zu struk-
turieren, dass sie die gewÃ¼nschte Struktur der Software abbildet.


Das zentrale Konstrukt des Paose Ansatzes und die Sicht auf Multiagentensys-
teme ist die Paose Matrix. Paose umfasst drei Betrachtungsperspektiven bzw.
Dimensionen, welche ein Multiagentensystem hinreichend beschreiben: Die Struk-
tur, das Verhalten und die Ontologie.


Die Struktur umfasst die verschiedenen Rollen, welche von Agenten eingenom-
men werden kÃ¶nnen. Das Verhalten beschreibt die mÃ¶glichen Interaktionen der
einzelnen Rollen. Nicht alle Rollen interagieren mit allen anderen Rollen, jedoch
ist bei einer mÃ¶glichen Interaktion ein gemeinsames VerstÃ¤ndnis von Konzepten
und Terminologien nÃ¶tig. Dieses VerstÃ¤ndnis wird durch die dritte Dimension, der
Ontologie, ausgedrÃ¼ckt. Abbildung 2.5 aus (Cabac, 2010) zeigt diesen Zusam-
menhang beispielhaft und fÃ¼r Verhalten und Struktur bildlich. Ontologien mÃ¼ssen
fÃ¼r die mit roten Kreisen markierten Ãœberschneidungen definiert sein, da dort eine
Interaktionskomponente mit einer Rollenkomponente in Beziehung steht.


Entwicklungsprozess


Der Entwicklungsprozess nach Paose umfasst mehrere Stufen. ZunÃ¤chst werden
im Sinne des Requirements Engineerings grundlegende Rollen identifiziert und in
einem Â»Coarse Design Diagram (CDD)Â« festgehalten. Auf dieser Basis werden
sodann Interaktionen mit der Hilfe sogenannter Â»Agenteninteraktionsprotokolle
(AIPs)Â« beschrieben. Weitere Ableitungen sind Rollen und AbhÃ¤ngigkeiten und
die benÃ¶tigten Ontologien. Im vollen Prozess werden aus den identifizierten AIPs
Protokolle in Form von Petrinetzen (sogenannte Â»ProtokollnetzeÂ«) fÃ¼r die Agen-
ten konstruiert, aus Rollen und AbhÃ¤ngigkeiten werden Entscheidungskomponen-
ten generiert und aus den Ontologien Ontologieklassen und Wissensbasen.


Viele Aspekte des Paose-Ansatzes und -Prozesses sind auch fÃ¼r diese Arbeit
interessant und sollen Anwendung finden. Insbesondere die Beschreibung von In-


teraktionen durch AIPs wird genutzt werden sowie das (implizite) VerstÃ¤ndnis
von Rollen im System. Der vollstÃ¤ndige Weg bis hin zur Capa Plattform wird
jedoch nicht umgesetzt. Die BegrÃ¼ndung liegt darin, dass die Capa Plattform
in ihrer Form die Notwendigkeiten im Rahmen der Forschungsfragen der Arbeit
nicht in hinreichendem Umfang liefert. Weitere Details und BegrÃ¼ndungen hierzu
werden in Abschnitt 4.3.3 aufgegriffen werden.


Abbildung 2.6 zeigt ein beispielhaftes AIP, wie es auch im verbleibenden Teil der
Arbeit auftreten wird. Einige Details sind dabei vereinfacht dargestellt wie bei-
spielsweise die explizite Unterscheidung von proaktiven und reaktiven Anteilen.
Beschrieben sind im Beispiel vier Rollen und deren Interaktionen untereinander.
Rolle 1 startet den Prozess proaktiv. Rolle 2, Rolle 3 und Rolle 4 starten durch
den eingehenden Pfeil die Aktionen 2-A, 3-A und 4-A jeweils reaktiv. In Rolle
4 ist ein sogenannter Â»XOR-SplitÂ« zu beobachten, bei dem je nach einer Bedin-
gung nur eine der Aktionen ausgefÃ¼hrt wird aber niemals beide. Rolle 3 weist
einen entsprechenden Â»AND-SplitÂ« auf, welcher stets beide Aktionen ausfÃ¼hrt.
Sind beide Aktionen ausgefÃ¼hrt, wartet Rolle 3 auf eine Nachricht von Rolle 4
(Aktion 3-C), welche abgeschickt wird, sobald die entsprechend der Bedingung
ausgewÃ¤hlte Aktion von Rolle 4 und nachfolgend Aktion 4-C ausgefÃ¼hrt wurde.


2.5. Architekturen und Systeme


Die Architektur einer Software ist ein entscheidender Aspekt der Softwareent-
wicklung. Da im Rahmen der Arbeit eine Architektur beschrieben bzw. entworfen
werden soll, liegt es nahe, zunÃ¤chst den Begriff zu definieren. Zu diesem Zweck
soll das Standardwerk von Bass et al. in seiner aktuellen, vierten Auflage heran-
gezogen werden:


Definition 2.12 (Softwarearchitektur). The software architec-
ture of a system is the set of structures needed to reason about
the system. These structures comprise software elements, relati-
ons among them, and properties of both.
(dt.: Die Softwarearchitektur eines Systems ist die Menge an
Strukturen, welche benÃ¶tigt wird, um Ã¼ber ein System nachzu-
denken. Diese Strukturen umfassen Softwareelemente, die Bezie-
hungen zwischen diesen und die jeweils zugehÃ¶rigen Eigenschaf-
ten.)


(Bass u. a., 2021, Kapitel 1.1)


Das Ziel ist somit sowohl Komponenten als auch Beziehungen zu beschreiben, um
ein zielgerichtetes Durchdenken der Software zu ermÃ¶glichen. Vor diesem Hin-


